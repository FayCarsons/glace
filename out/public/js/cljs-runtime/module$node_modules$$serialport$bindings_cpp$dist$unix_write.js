shadow$provide.module$node_modules$$serialport$bindings_cpp$dist$unix_write=function(global,require,module,exports){module=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod}};Object.defineProperty(exports,"__esModule",{value:!0});exports.unixWrite=void 0;global=require("shadow$empty");module=module(require("module$node_modules$debug$src$browser"));require=require("module$node_modules$util$util");const logger=(0,module.default)("serialport/bindings-cpp/unixWrite"),
writeAsync=(0,require.promisify)(global.write),writable=binding=>new Promise((resolve,reject)=>{binding.poller.once("writable",err=>err?reject(err):resolve())});exports.unixWrite=async({binding,buffer,offset=0,fsWriteAsync=writeAsync})=>{const bytesToWrite=buffer.length-offset;logger("Starting write",buffer.length,"bytes offset",offset,"bytesToWrite",bytesToWrite);if(!binding.isOpen||!binding.fd)throw Error("Port is not open");try{const {bytesWritten}=await fsWriteAsync(binding.fd,buffer,offset,bytesToWrite);
logger("write returned: wrote",bytesWritten,"bytes");if(bytesWritten+offset<buffer.length){if(!binding.isOpen)throw Error("Port is not open");return(0,exports.unixWrite)({binding,buffer,offset:bytesWritten+offset,fsWriteAsync})}logger("Finished writing",bytesWritten+offset,"bytes")}catch(err){logger("write errored",err);if("EAGAIN"===err.code||"EWOULDBLOCK"===err.code||"EINTR"===err.code){if(!binding.isOpen)throw Error("Port is not open");logger("waiting for writable because of code:",err.code);await writable(binding);
return(0,exports.unixWrite)({binding,buffer,offset,fsWriteAsync})}if("EBADF"===err.code||"ENXIO"===err.code||"UNKNOWN"===err.code||-1===err.errno)err.disconnect=!0,logger("disconnecting",err);logger("error",err);throw err;}}}
//# sourceMappingURL=module$node_modules$$serialport$bindings_cpp$dist$unix_write.js.map
