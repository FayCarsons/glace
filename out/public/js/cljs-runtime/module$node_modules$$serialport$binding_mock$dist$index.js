shadow$provide.module$node_modules$$serialport$binding_mock$dist$index=function(global,require,module,exports){function resolveNextTick(){return new Promise(resolve=>process.nextTick(()=>resolve()))}var process=require("module$node_modules$process$browser"),Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";Object.defineProperty(exports,"__esModule",{value:!0});global=require("module$node_modules$debug$src$browser");const debug=(global&&"object"===typeof global&&"default"in global?
global:{"default":global})["default"]("serialport/binding-mock");let ports={},serialNumber=0;class CanceledError extends Error{constructor(message){super(message);this.canceled=!0}}class MockPortBinding{constructor(port,openOptions){this.port=port;this.openOptions=openOptions;this.pendingRead=null;this.isOpen=!0;this.lastWrite=null;this.recording=Buffer.alloc(0);this.writeOperation=null;this.serialNumber=port.info.serialNumber;if(port.readyData){const data=port.readyData;process.nextTick(()=>{this.isOpen&&
(debug(this.serialNumber,"emitting ready data"),this.emitData(data))})}}emitData(data){if(!this.isOpen||!this.port)throw Error("Port must be open to pretend to receive data");data=Buffer.isBuffer(data)?data:Buffer.from(data);debug(this.serialNumber,"emitting data - pending read:",!!this.pendingRead);this.port.data=Buffer.concat([this.port.data,data]);this.pendingRead&&(process.nextTick(this.pendingRead),this.pendingRead=null)}async close(){debug(this.serialNumber,"close");if(!this.isOpen)throw Error("Port is not open");
const port=this.port;if(!port)throw Error("already closed");port.openOpt=void 0;port.data=Buffer.alloc(0);debug(this.serialNumber,"port is closed");this.serialNumber=void 0;this.isOpen=!1;this.pendingRead&&this.pendingRead(new CanceledError("port is closed"))}async read(buffer,offset,length){if(!Buffer.isBuffer(buffer))throw new TypeError('"buffer" is not a Buffer');if("number"!==typeof offset||isNaN(offset))throw new TypeError(`"offset" is not an integer got "${isNaN(offset)?"NaN":typeof offset}"`);
if("number"!==typeof length||isNaN(length))throw new TypeError(`"length" is not an integer got "${isNaN(length)?"NaN":typeof length}"`);if(buffer.length<offset+length)throw Error("buffer is too small");if(!this.isOpen)throw Error("Port is not open");debug(this.serialNumber,"read",length,"bytes");await resolveNextTick();if(!this.isOpen||!this.port)throw new CanceledError("Read canceled");if(0>=this.port.data.length)return new Promise((resolve,reject)=>{this.pendingRead=err=>{if(err)return reject(err);
this.read(buffer,offset,length).then(resolve,reject)}});const lengthToRead=this.port.maxReadSize>length?length:this.port.maxReadSize,bytesRead=this.port.data.slice(0,lengthToRead).copy(buffer,offset);this.port.data=this.port.data.slice(lengthToRead);debug(this.serialNumber,"read",bytesRead,"bytes");return{bytesRead,buffer}}async write(buffer){if(!Buffer.isBuffer(buffer))throw new TypeError('"buffer" is not a Buffer');if(!this.isOpen||!this.port)throw debug("write","error port is not open"),Error("Port is not open");
debug(this.serialNumber,"write",buffer.length,"bytes");if(this.writeOperation)throw Error("Overlapping writes are not supported and should be queued by the serialport object");return this.writeOperation=(async()=>{await resolveNextTick();if(!this.isOpen||!this.port)throw Error("Write canceled");const data=this.lastWrite=Buffer.from(buffer);this.port.record&&(this.recording=Buffer.concat([this.recording,data]));this.port.echo&&process.nextTick(()=>{this.isOpen&&this.emitData(data)});this.writeOperation=
null;debug(this.serialNumber,"writing finished")})()}async update(options){if("object"!==typeof options)throw TypeError('"options" is not an object');if("number"!==typeof options.baudRate)throw new TypeError('"options.baudRate" is not a number');debug(this.serialNumber,"update");if(!this.isOpen||!this.port)throw Error("Port is not open");await resolveNextTick();this.port.openOpt&&(this.port.openOpt.baudRate=options.baudRate)}async set(options){if("object"!==typeof options)throw new TypeError('"options" is not an object');
debug(this.serialNumber,"set");if(!this.isOpen)throw Error("Port is not open");await resolveNextTick()}async get(){debug(this.serialNumber,"get");if(!this.isOpen)throw Error("Port is not open");await resolveNextTick();return{cts:!0,dsr:!1,dcd:!1}}async getBaudRate(){var _a;debug(this.serialNumber,"getBaudRate");if(!this.isOpen||!this.port)throw Error("Port is not open");await resolveNextTick();if(null===(_a=this.port.openOpt)||void 0===_a||!_a.baudRate)throw Error("Internal Error");return{baudRate:this.port.openOpt.baudRate}}async flush(){debug(this.serialNumber,
"flush");if(!this.isOpen||!this.port)throw Error("Port is not open");await resolveNextTick();this.port.data=Buffer.alloc(0)}async drain(){debug(this.serialNumber,"drain");if(!this.isOpen)throw Error("Port is not open");await this.writeOperation;await resolveNextTick()}}exports.CanceledError=CanceledError;exports.MockBinding={reset(){ports={};serialNumber=0},createPort(path,options={}){serialNumber++;const optWithDefaults=Object.assign({echo:!1,record:!1,manufacturer:"The J5 Robotics Company",vendorId:void 0,
productId:void 0,maxReadSize:1024},options);ports[path]={data:Buffer.alloc(0),echo:optWithDefaults.echo,record:optWithDefaults.record,readyData:optWithDefaults.readyData,maxReadSize:optWithDefaults.maxReadSize,info:{path,manufacturer:optWithDefaults.manufacturer,serialNumber:`${serialNumber}`,pnpId:void 0,locationId:void 0,vendorId:optWithDefaults.vendorId,productId:optWithDefaults.productId}};debug(serialNumber,"created port",JSON.stringify({path,opt:options}))},async list(){debug(null,"list");return Object.values(ports).map(port=>
port.info)},async open(options){var _a;if(!options||"object"!==typeof options||Array.isArray(options))throw new TypeError('"options" is not an object');if(!options.path)throw new TypeError('"path" is not a valid port');if(!options.baudRate)throw new TypeError('"baudRate" is not a valid baudRate');options=Object.assign({dataBits:8,lock:!0,stopBits:1,parity:"none",rtscts:!1,xon:!1,xoff:!1,xany:!1,hupcl:!0},options);const {path}=options;debug(null,`open: opening path ${path}`);const port=ports[path];
await resolveNextTick();if(!port)throw Error(`Port does not exist - please call MockBinding.createPort('${path}') first`);const serialNumber=port.info.serialNumber;if(null===(_a=port.openOpt)||void 0===_a?0:_a.lock)throw debug(serialNumber,"open: Port is locked cannot open"),Error("Port is locked cannot open");debug(serialNumber,`open: opened path ${path}`);port.openOpt=Object.assign({},options);return new MockPortBinding(port,options)}};exports.MockPortBinding=MockPortBinding}
//# sourceMappingURL=module$node_modules$$serialport$binding_mock$dist$index.js.map
