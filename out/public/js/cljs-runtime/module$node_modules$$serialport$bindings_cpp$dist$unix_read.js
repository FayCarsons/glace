shadow$provide.module$node_modules$$serialport$bindings_cpp$dist$unix_read=function(global,require,module,exports){global=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod}};Object.defineProperty(exports,"__esModule",{value:!0});exports.unixRead=void 0;module=require("module$node_modules$util$util");const fs_1=require("shadow$empty"),errors_1=require("module$node_modules$$serialport$bindings_cpp$dist$errors"),logger=(0,global(require("module$node_modules$debug$src$browser")).default)("serialport/bindings-cpp/unixRead"),
readAsync=(0,module.promisify)(fs_1.read),readable=binding=>new Promise((resolve,reject)=>{if(!binding.poller)throw Error("No poller on bindings");binding.poller.once("readable",err=>err?reject(err):resolve())});exports.unixRead=async({binding,buffer,offset,length,fsReadAsync=readAsync})=>{logger("Starting read");if(!binding.isOpen||!binding.fd)throw new errors_1.BindingsError("Port is not open",{canceled:!0});try{const {bytesRead}=await fsReadAsync(binding.fd,buffer,offset,length,null);if(0===bytesRead)return(0,exports.unixRead)({binding,
buffer,offset,length,fsReadAsync});logger("Finished read",bytesRead,"bytes");return{bytesRead,buffer}}catch(err){logger("read error",err);if("EAGAIN"===err.code||"EWOULDBLOCK"===err.code||"EINTR"===err.code){if(!binding.isOpen)throw new errors_1.BindingsError("Port is not open",{canceled:!0});logger("waiting for readable because of code:",err.code);await readable(binding);return(0,exports.unixRead)({binding,buffer,offset,length,fsReadAsync})}if("EBADF"===err.code||"ENXIO"===err.code||"UNKNOWN"===
err.code||-1===err.errno)err.disconnect=!0,logger("disconnecting",err);throw err;}}}
//# sourceMappingURL=module$node_modules$$serialport$bindings_cpp$dist$unix_read.js.map
