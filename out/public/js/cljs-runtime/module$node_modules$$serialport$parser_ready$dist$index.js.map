{
"version":3,
"file":"module$node_modules$$serialport$parser_ready$dist$index.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,uDAAA,CAA4E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CACpH,IAAIC,OAASH,OAAA,CAAQ,kCAAR,CAAkBG,CAAAA,MAC/B,aACAC,OAAOC,CAAAA,cAAP,CAAsBH,OAAtB,CAA+B,YAA/B,CAA6C,CAAEI,MAAO,CAAA,CAAT,CAA7C,CACAJ,QAAQK,CAAAA,WAAR,CAAsB,IAAK,EACrBC,OAAAA,CAAWR,OAAA,CAAQ,6CAAR,CAMjB,MAAMO,YAAN,QAA0BC,OAASC,CAAAA,SAAnC,CACIC,WAAW,CAAC,CAAEC,SAAF,CAAa,GAAGC,OAAhB,CAAD,CAA4B,CACnC,GAAkBC,IAAAA,EAAlB,GAAIF,SAAJ,CACI,KAAM,KAAIG,SAAJ,CAAc,wCAAd,CAAN,CAEJ,GAAyB,CAAzB,GAAIH,SAAUI,CAAAA,MAAd,CACI,KAAM,KAAID,SAAJ,CAAc,yCAAd,CAAN;AAEJ,KAAA,CAAMF,OAAN,CACA,KAAKD,CAAAA,SAAL,CAAiBR,MAAOa,CAAAA,IAAP,CAAYL,SAAZ,CACjB,KAAKM,CAAAA,UAAL,CAAkB,CAClB,KAAKC,CAAAA,KAAL,CAAa,CAAA,CAVsB,CAYvCC,UAAU,CAACC,KAAD,CAAQC,QAAR,CAAkBC,EAAlB,CAAsB,CAC5B,GAAI,IAAKJ,CAAAA,KAAT,CAEI,MADA,KAAKK,CAAAA,IAAL,CAAUH,KAAV,CACO,CAAAE,EAAA,EAELX,SAAAA,CAAY,IAAKA,CAAAA,SACvB,KAAIa,YAAc,CAClB,KAAA,CAAO,IAAKP,CAAAA,UAAZ,CAAyBN,QAAUI,CAAAA,MAAnC,EAA6CS,WAA7C,CAA2DJ,KAAML,CAAAA,MAAjE,CAAA,CACQJ,QAAA,CAAU,IAAKM,CAAAA,UAAf,CAAJ,GAAmCG,KAAA,CAAMI,WAAN,CAAnC,CACI,IAAKP,CAAAA,UAAL,EADJ,CAII,IAAKA,CAAAA,UAJT,CAIsB,CAEtB,CAAAO,WAAA,EAEA,KAAKP,CAAAA,UAAT,GAAwBN,QAAUI,CAAAA,MAAlC,GACI,IAAKG,CAAAA,KAGL,CAHa,CAAA,CAGb,CAFA,IAAKO,CAAAA,IAAL,CAAU,OAAV,CAEA,CADMC,KACN,CADkBN,KAAMO,CAAAA,KAAN,CAAYH,WAAZ,CAClB,CAAuB,CAAvB,CAAIE,KAAUX,CAAAA,MAAd,EACI,IAAKQ,CAAAA,IAAL,CAAUG,KAAV,CALR,CAQAJ,GAAA,EAxB4B,CAbpC;AAwCApB,OAAQK,CAAAA,WAAR,CAAsBA,WAnD8F;",
"sources":["node_modules/@serialport/parser-ready/dist/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$serialport$parser_ready$dist$index\"] = function(global,require,module,exports) {\nvar Buffer = require('buffer').Buffer;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadyParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that waits for a sequence of \"ready\" bytes before emitting a ready event and emitting data events\n *\n * To use the `Ready` parser provide a byte start sequence. After the bytes have been received a ready event is fired and data events are passed through.\n */\nclass ReadyParser extends stream_1.Transform {\n    constructor({ delimiter, ...options }) {\n        if (delimiter === undefined) {\n            throw new TypeError('\"delimiter\" is not a bufferable object');\n        }\n        if (delimiter.length === 0) {\n            throw new TypeError('\"delimiter\" has a 0 or undefined length');\n        }\n        super(options);\n        this.delimiter = Buffer.from(delimiter);\n        this.readOffset = 0;\n        this.ready = false;\n    }\n    _transform(chunk, encoding, cb) {\n        if (this.ready) {\n            this.push(chunk);\n            return cb();\n        }\n        const delimiter = this.delimiter;\n        let chunkOffset = 0;\n        while (this.readOffset < delimiter.length && chunkOffset < chunk.length) {\n            if (delimiter[this.readOffset] === chunk[chunkOffset]) {\n                this.readOffset++;\n            }\n            else {\n                this.readOffset = 0;\n            }\n            chunkOffset++;\n        }\n        if (this.readOffset === delimiter.length) {\n            this.ready = true;\n            this.emit('ready');\n            const chunkRest = chunk.slice(chunkOffset);\n            if (chunkRest.length > 0) {\n                this.push(chunkRest);\n            }\n        }\n        cb();\n    }\n}\nexports.ReadyParser = ReadyParser;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Buffer","Object","defineProperty","value","ReadyParser","stream_1","Transform","constructor","delimiter","options","undefined","TypeError","length","from","readOffset","ready","_transform","chunk","encoding","cb","push","chunkOffset","emit","chunkRest","slice"]
}
