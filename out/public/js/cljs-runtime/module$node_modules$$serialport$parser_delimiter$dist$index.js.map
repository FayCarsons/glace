{
"version":3,
"file":"module$node_modules$$serialport$parser_delimiter$dist$index.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,2DAAA,CAAgF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CACxH,IAAIC,OAASH,OAAA,CAAQ,kCAAR,CAAkBG,CAAAA,MAC/B,aACAC,OAAOC,CAAAA,cAAP,CAAsBH,OAAtB,CAA+B,YAA/B,CAA6C,CAAEI,MAAO,CAAA,CAAT,CAA7C,CACAJ,QAAQK,CAAAA,eAAR,CAA0B,IAAK,EACzBC,OAAAA,CAAWR,OAAA,CAAQ,6CAAR,CAOjB,MAAMO,gBAAN,QAA8BC,OAASC,CAAAA,SAAvC,CACIC,WAAW,CAAC,CAAEC,SAAF,CAAaC,gBAAA,CAAmB,CAAA,CAAhC,CAAuC,GAAGC,OAA1C,CAAD,CAAsD,CAC7D,KAAA,CAAMA,OAAN,CACA,IAAkBC,IAAAA,EAAlB,GAAIH,SAAJ,CACI,KAAM,KAAII,SAAJ,CAAc,wCAAd,CAAN;AAEJ,GAAyB,CAAzB,GAAIJ,SAAUK,CAAAA,MAAd,CACI,KAAM,KAAID,SAAJ,CAAc,yCAAd,CAAN,CAEJ,IAAKH,CAAAA,gBAAL,CAAwBA,gBACxB,KAAKD,CAAAA,SAAL,CAAiBR,MAAOc,CAAAA,IAAP,CAAYN,SAAZ,CACjB,KAAKO,CAAAA,MAAL,CAAcf,MAAOgB,CAAAA,KAAP,CAAa,CAAb,CAV+C,CAYjEC,UAAU,CAACC,KAAD,CAAQC,QAAR,CAAkBC,EAAlB,CAAsB,CAG5B,IAFIC,KAEJ,CAFWrB,MAAOsB,CAAAA,MAAP,CAAc,CAAC,IAAKP,CAAAA,MAAN,CAAcG,KAAd,CAAd,CAEX,CAAqD,CAAC,CAAtD,IAAQK,QAAR,CAAmBF,KAAKG,CAAAA,OAAL,CAAa,IAAKhB,CAAAA,SAAlB,CAAnB,EAAA,CACI,IAAKiB,CAAAA,IAAL,CAAUJ,KAAKK,CAAAA,KAAL,CAAW,CAAX,CAAcH,QAAd,EAA0B,IAAKd,CAAAA,gBAAL,CAAwB,IAAKD,CAAAA,SAAUK,CAAAA,MAAvC,CAAgD,CAA1E,EAAV,CACA,CAAAQ,KAAA,CAAOA,KAAKK,CAAAA,KAAL,CAAWH,QAAX,CAAsB,IAAKf,CAAAA,SAAUK,CAAAA,MAArC,CAEX,KAAKE,CAAAA,MAAL,CAAcM,KACdD,GAAA,EAR4B,CAUhCO,MAAM,CAACP,EAAD,CAAK,CACP,IAAKK,CAAAA,IAAL,CAAU,IAAKV,CAAAA,MAAf,CACA;IAAKA,CAAAA,MAAL,CAAcf,MAAOgB,CAAAA,KAAP,CAAa,CAAb,CACdI,GAAA,EAHO,CAvBf,CA6BArB,OAAQK,CAAAA,eAAR,CAA0BA,eAzC8F;",
"sources":["node_modules/@serialport/parser-delimiter/dist/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$serialport$parser_delimiter$dist$index\"] = function(global,require,module,exports) {\nvar Buffer = require('buffer').Buffer;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DelimiterParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that emits data each time a byte sequence is received.\n * @extends Transform\n *\n * To use the `Delimiter` parser, provide a delimiter as a string, buffer, or array of bytes. Runs in O(n) time.\n */\nclass DelimiterParser extends stream_1.Transform {\n    constructor({ delimiter, includeDelimiter = false, ...options }) {\n        super(options);\n        if (delimiter === undefined) {\n            throw new TypeError('\"delimiter\" is not a bufferable object');\n        }\n        if (delimiter.length === 0) {\n            throw new TypeError('\"delimiter\" has a 0 or undefined length');\n        }\n        this.includeDelimiter = includeDelimiter;\n        this.delimiter = Buffer.from(delimiter);\n        this.buffer = Buffer.alloc(0);\n    }\n    _transform(chunk, encoding, cb) {\n        let data = Buffer.concat([this.buffer, chunk]);\n        let position;\n        while ((position = data.indexOf(this.delimiter)) !== -1) {\n            this.push(data.slice(0, position + (this.includeDelimiter ? this.delimiter.length : 0)));\n            data = data.slice(position + this.delimiter.length);\n        }\n        this.buffer = data;\n        cb();\n    }\n    _flush(cb) {\n        this.push(this.buffer);\n        this.buffer = Buffer.alloc(0);\n        cb();\n    }\n}\nexports.DelimiterParser = DelimiterParser;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Buffer","Object","defineProperty","value","DelimiterParser","stream_1","Transform","constructor","delimiter","includeDelimiter","options","undefined","TypeError","length","from","buffer","alloc","_transform","chunk","encoding","cb","data","concat","position","indexOf","push","slice","_flush"]
}
