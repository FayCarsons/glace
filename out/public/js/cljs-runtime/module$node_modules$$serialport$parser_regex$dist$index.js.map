{
"version":3,
"file":"module$node_modules$$serialport$parser_regex$dist$index.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,uDAAA,CAA4E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAEpHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CACAH,QAAQI,CAAAA,WAAR,CAAsB,IAAK,EACrBC,OAAAA,CAAWP,OAAA,CAAQ,6CAAR,CAMjB,MAAMM,YAAN,QAA0BC,OAASC,CAAAA,SAAnC,CACIC,WAAW,CAAC,CAAEC,KAAF,CAAS,GAAGC,OAAZ,CAAD,CAAwB,CACzBC,OAAAA,CAAO,CACTC,SAAU,MADD,CAET,GAAGF,OAFM,CAIb,IAAcG,IAAAA,EAAd,GAAIJ,KAAJ,CACI,KAAM,KAAIK,SAAJ,CAAc,gEAAd,CAAN,CAEEL,KAAN,WAAuBM,OAAvB,GACIN,KADJ;AACY,IAAIM,MAAJ,CAAWN,KAAMO,CAAAA,QAAN,EAAX,CADZ,CAGA,MAAA,CAAML,OAAN,CACA,KAAKF,CAAAA,KAAL,CAAaA,KACb,KAAKQ,CAAAA,IAAL,CAAY,EAbmB,CAenCC,UAAU,CAACC,KAAD,CAAQP,QAAR,CAAkBQ,EAAlB,CAAsB,CAEtBC,KAAAA,CAAaC,CADN,IAAKL,CAAAA,IACCK,CADMH,KACNG,EAAAA,KAAL,CAAW,IAAKb,CAAAA,KAAhB,CACd,KAAKQ,CAAAA,IAAL,CAAYI,KAAME,CAAAA,GAAN,EAAZ,EAA2B,EAC3BF,MAAMG,CAAAA,OAAN,CAAcC,IAAA,EAAQ,CAClB,IAAKC,CAAAA,IAAL,CAAUD,IAAV,CADkB,CAAtB,CAGAL,GAAA,EAP4B,CAShCO,MAAM,CAACP,EAAD,CAAK,CACP,IAAKM,CAAAA,IAAL,CAAU,IAAKT,CAAAA,IAAf,CACA,KAAKA,CAAAA,IAAL,CAAY,EACZG,GAAA,EAHO,CAzBf,CA+BAnB,OAAQI,CAAAA,WAAR,CAAsBA,WAzC8F;",
"sources":["node_modules/@serialport/parser-regex/dist/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$serialport$parser_regex$dist$index\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RegexParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that uses a regular expression to split the incoming text upon.\n *\n * To use the `Regex` parser provide a regular expression to split the incoming text upon. Data is emitted as string controllable by the `encoding` option (defaults to `utf8`).\n */\nclass RegexParser extends stream_1.Transform {\n    constructor({ regex, ...options }) {\n        const opts = {\n            encoding: 'utf8',\n            ...options,\n        };\n        if (regex === undefined) {\n            throw new TypeError('\"options.regex\" must be a regular expression pattern or object');\n        }\n        if (!(regex instanceof RegExp)) {\n            regex = new RegExp(regex.toString());\n        }\n        super(opts);\n        this.regex = regex;\n        this.data = '';\n    }\n    _transform(chunk, encoding, cb) {\n        const data = this.data + chunk;\n        const parts = data.split(this.regex);\n        this.data = parts.pop() || '';\n        parts.forEach(part => {\n            this.push(part);\n        });\n        cb();\n    }\n    _flush(cb) {\n        this.push(this.data);\n        this.data = '';\n        cb();\n    }\n}\nexports.RegexParser = RegexParser;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","RegexParser","stream_1","Transform","constructor","regex","options","opts","encoding","undefined","TypeError","RegExp","toString","data","_transform","chunk","cb","parts","split","pop","forEach","part","push","_flush"]
}
