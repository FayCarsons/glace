{"version":3,"sources":["sprog/iglu/chunks/raytracing.cljs"],"mappings":"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","names":["sprog.iglu.chunks.raytracing/ray-chunk","sprog.iglu.chunks.raytracing/plane-intersection-chunk","sprog.iglu.core.combine_chunks","sprog.iglu.chunks.raytracing/sphere-intersection-chunk","sprog.iglu.chunks.raytracing/box-intersection-chunk","sprog.iglu.chunks.raytracing/plane-sdf-chunk","sprog.iglu.chunks.raytracing/raymarch-chunk","p__31216","vec__31217","map__31220","cljs.core.nth","cljs.core/--destructure-map","cljs.core.get","sdf-name","ray","maxDistance","step-factor","max-steps","termination-threshold","fn-name","cljs.core.gensym","clojure.walk/prewalk-replace","cljs.core/List","var_args","args__5772__auto__","len__5766__auto__","i__5767__auto__","argseq__5773__auto__","cljs.core/IndexedSeq","sprog.iglu.chunks.raytracing/create-sdf-normal-chunk","p__31237","vec__31239","map__31242","seq31234","G__31235","cljs.core/first","cljs.core/next","self__5751__auto__","sample-distance","clojure.walk/postwalk-replace","sprog.iglu.chunks.raytracing/perspective-camera-chunk","sprog.iglu.chunks.raytracing/get-voxel-intersection-chunk","p__31253","vec__31254","map__31257","seq31249","self__5752__auto__","cljs.core/seq","max-voxel-steps","return-type","default-return-expression","hit-expression","cljs.core.concat","sprog.iglu.chunks.raytracing/get-column-intersection-chunk","p__31273","vec__31274","seq31265","G__31266","G__31267","G__31268","or__5043__auto__","sprog.iglu.chunks.raytracing/capsule-intersection-chunk","sprog.iglu.chunks.raytracing/cylinder-intersection-chunk"],"sourcesContent":["(ns sprog.iglu.chunks.raytracing\n  (:require [sprog.util :as u]\n            [clojure.walk :refer [postwalk-replace]]\n            [sprog.iglu.core :refer [combine-chunks]]))\n\n(def ray-chunk\n  '{:structs {Ray [pos vec3\n                   dir vec3]}})\n\n(def plane-intersection-chunk\n  (combine-chunks ray-chunk\n                '{:functions {findPlaneIntersection\n                              {([Ray Ray] float)\n                               ([ray planeRay]\n                                (/ (dot (- planeRay.pos ray.pos) planeRay.dir)\n                                   (dot ray.dir planeRay.dir)))}}}))\n\n(def sphere-intersection-chunk\n  (combine-chunks ray-chunk\n                '{:functions\n                  {findSphereIntersections\n                   {([Ray vec3 float] vec2)\n                    ([ray sphereCenter sphereRadius]\n                     (=vec3 offset (- ray.pos sphereCenter))\n                     (=float halfB (dot offset ray.dir))\n                     (=float c (- (dot offset offset)\n                                  (* sphereRadius sphereRadius)))\n                     (=float discriminant (- (* halfB halfB) c))\n                     (\"if\" (> discriminant 0)\n                           (=float discriminantSqrt (sqrt discriminant))\n                           (return (- 0\n                                      (vec2 (+ halfB discriminantSqrt)\n                                            (- halfB discriminantSqrt)))))\n                     (vec2 0))}}}))\n\n; based on https://iquilezles.org/articles/boxfunctions/\n(def box-intersection-chunk\n  (combine-chunks\n   ray-chunk\n   '{:structs {BoxIntersection [hit bool\n                                frontDist float\n                                backDist float\n                                frontNorm vec3]}\n     :functions {findBoxIntersection\n                 {([Ray vec3 vec3] BoxIntersection)\n                  ([ray pos size]\n                   (=vec3 m (/ 1 ray.dir))\n                   (=vec3 n (* m (- ray.pos pos)))\n                   (=vec3 k (* (abs m) size))\n                   (=vec3 t1 (- 0 (+ n k)))\n                   (=vec3 t2 (- k n))\n\n                   (=float tN (max (max t1.x t1.y) t1.z))\n                   (=float tF (min (min t2.x t2.y) t2.z))\n                   (\"if\" (|| (> tN tF)\n                             (< tF 0))\n                         (return (BoxIntersection \"false\"\n                                                  0\n                                                  0\n                                                  (vec3 0))))\n                   (BoxIntersection \"true\"\n                                    tN\n                                    tF\n                                    (- 0\n                                       (* (sign ray.dir)\n                                          (step t1.yzx t1.xyz)\n                                          (step t1.zxy t1.xyz)))))}}}))\n\n(def plane-sdf-chunk\n  (combine-chunks ray-chunk\n                '{:functions {sdPlane\n                              {([vec3 Ray] float)\n                               ([pos planeRay]\n                                (dot (- planeRay.pos pos) planeRay.dir))}}}))\n\n(def raymarch-chunk\n  (combine-chunks\n   ray-chunk\n   {:macros\n    {'raymarch\n     (fn [sdf-name\n          ray\n          maxDistance\n          & [{:keys [step-factor\n                     max-steps\n                     termination-threshold]\n              :or {step-factor 1\n                   max-steps 1024\n                   termination-threshold 0.0001}}]]\n       (let [fn-name (gensym 'march)]\n         (u/unquotable\n          '{:chunk\n            {:functions\n             {~fn-name\n              {([Ray float] float)\n               ([ray maxDistance]\n                (=float t 0)\n                (~(str \"for(int i=0;i<\" max-steps \";i++)\")\n                 (=float distanceEstimate\n                         (~sdf-name (+ ray.pos (* t ray.dir))))\n                 (\"if\" (< (abs distanceEstimate)\n                          ~termination-threshold)\n                       (return t))\n                 (+= t (* distanceEstimate ~step-factor))\n                 (\"if\" (> t maxDistance) \"break\"))\n                -1)}}}\n            :expression ~(list fn-name ray maxDistance)})))}}))\n\n(defn create-sdf-normal-chunk [sdf-name & [{:keys [sample-distance\n                                                   fn-name]\n                                            :or {sample-distance 0.001\n                                                 fn-name 'sdfNorm}}]]\n  (postwalk-replace\n   {:sample-distance sample-distance\n    :sdf-name sdf-name\n    :fn-name fn-name}\n   '{:functions\n     {:fn-name\n      {([vec3] vec3)\n       ([pos]\n        (normalize\n         (vec3 (- (:sdf-name (+ pos (vec3 :sample-distance 0 0)))\n                  (:sdf-name (- pos (vec3 :sample-distance 0 0))))\n               (- (:sdf-name (+ pos (vec3 0 :sample-distance 0)))\n                  (:sdf-name (- pos (vec3 0 :sample-distance 0))))\n               (- (:sdf-name (+ pos (vec3 0 0 :sample-distance)))\n                  (:sdf-name (- pos (vec3 0 0 :sample-distance)))))))}}}))\n\n(def perspective-camera-chunk\n  (combine-chunks ray-chunk\n                '{:functions\n                  {cameraRay\n                   {([vec2 vec3 vec3 float] Ray)\n                    ([screenPos camTarget camPos focalDist]\n                     (=vec3 camDir (normalize (- camTarget camPos)))\n                     (=vec3 camRight (normalize (cross camDir (vec3 0 1 0))))\n                     (=vec3 camUp (cross camRight camDir))\n\n                     (=vec3 filmPos (+ (* camDir focalDist)\n                                       (* (- screenPos.x 0.5) camRight)\n                                       (* (- screenPos.y 0.5) camUp)))\n\n                     (Ray camPos (normalize filmPos)))}}}))\n\n(defn get-voxel-intersection-chunk\n  [& [{:keys [max-voxel-steps\n              return-type\n              default-return-expression\n              hit-expression]\n       :or {max-voxel-steps 1000000\n            return-type 'VoxelIntersection\n            default-return-expression '(VoxelIntersection \"false\"\n                                                          (ivec3 \"0\")\n                                                          (vec3 0)\n                                                          (vec3 0))\n            hit-expression '((return voxelIntersection))}}]]\n  (combine-chunks\n   ray-chunk\n   (postwalk-replace\n    {:max-voxel-steps (str max-voxel-steps)\n     :return-type return-type\n     :default-return-expression default-return-expression\n     :voxel-hit-expression\n     (concat\n      (list \"if\"\n            '(voxelFilled voxelCoords)\n            '(=VoxelIntersection voxelIntersection\n                                 (VoxelIntersection \"true\"\n                                                    voxelCoords\n                                                    (+ ray.pos\n                                                       (* ray.dir dist))\n                                                    norm)))\n      hit-expression)}\n    '{:structs {VoxelIntersection [hit bool\n                                   gridPos ivec3\n                                   pos vec3\n                                   norm vec3]}\n      :functions\n      {findVoxelIntersection\n       {([Ray float] :return-type)\n        ([ray maxDist]\n         (=ivec3 voxelCoords (ivec3 (floor ray.pos)))\n         (=vec3 innerCoords (fract ray.pos))\n\n         (=ivec3 step (ivec3 (sign ray.dir)))\n         (=vec3 delta (/ (vec3 step) ray.dir))\n\n         (=vec3 tMax (* delta\n                        (vec3 (if (> ray.dir.x \"0.0\")\n                                (- \"1.0\" innerCoords.x)\n                                innerCoords.x)\n                              (if (> ray.dir.y \"0.0\")\n                                (- \"1.0\" innerCoords.y)\n                                innerCoords.y)\n                              (if (> ray.dir.z \"0.0\")\n                                (- \"1.0\" innerCoords.z)\n                                innerCoords.z))))\n\n         (=vec3 norm (vec3 0))\n         (=int maxVoxelSteps :max-voxel-steps)\n         (\"for(int i=0;i<maxVoxelSteps;i++)\"\n          (=vec3 t\n                 (min (/ (- (vec3 voxelCoords) ray.pos) ray.dir)\n                      (/ (- (vec3 (+ (vec3 voxelCoords) 1)) ray.pos) ray.dir)))\n          (=float dist (max (max t.x t.y) t.z))\n          (\"if\" (>= dist maxDist) (return :default-return-expression))\n          :voxel-hit-expression\n          (\"if\" (< tMax.x tMax.y)\n                (\"if\" (< tMax.z tMax.x)\n                      (+= tMax.z delta.z)\n                      (+= voxelCoords.z step.z)\n                      (= norm (vec3 0 0 (- \"0.0\" (float step.z)))))\n                (\"else\"\n                 (+= tMax.x delta.x)\n                 (+= voxelCoords.x step.x)\n                 (= norm (vec3 (- \"0.0\" (float step.x)) 0 0))))\n          (\"else\" (\"if\" (< tMax.z tMax.y)\n                        (+= tMax.z delta.z)\n                        (+= voxelCoords.z step.z)\n                        (= norm (vec3 0 0 (- \"0.0\" (float step.z)))))\n                  (\"else\"\n                   (+= tMax.y delta.y)\n                   (+= voxelCoords.y step.y)\n                   (= norm (vec3 0 (- \"0.0\" (float step.y)) 0)))))\n         :default-return-expression)}}})))\n\n(defn get-column-intersection-chunk [return-type\n                                     default-return-expression\n                                     hit-expression\n                                     & [max-steps]]\n  (combine-chunks\n   ray-chunk\n   (postwalk-replace\n    {:max-steps (str (or max-steps 1000000))\n     :return-type return-type\n     :default-return-expression default-return-expression\n     :column-hit-expression\n     (concat\n      '(\"if\" (columnFilled gridCoords))\n      hit-expression)}\n    '{:functions\n      {findColumnIntersection\n       {([Ray float] :return-type)\n        ([ray maxDist]\n\n         (=vec2 rayPos ray.pos.xy)\n         (=vec2 rayDir (normalize ray.dir.xy))\n\n         (=ivec2 gridCoords (ivec2 (floor rayPos)))\n         (=vec2 innerCoords (fract rayPos))\n\n         (=ivec2 step (ivec2 (sign rayDir)))\n         (=vec2 delta (/ (vec2 step) rayDir))\n\n         (=vec2 tMax (* delta\n                        (vec2 (if (> rayDir.x \"0.0\")\n                                (- \"1.0\" innerCoords.x)\n                                innerCoords.x)\n                              (if (> rayDir.y \"0.0\")\n                                (- \"1.0\" innerCoords.y)\n                                innerCoords.y))))\n\n         (=vec3 norm (vec3 0))\n         (=int maxSteps :max-steps)\n         (\"for(int i=0;i<maxSteps;i++)\"\n          (=vec2 t\n                 (min (/ (- (vec2 gridCoords) rayPos) rayDir)\n                      (/ (- (vec2 (+ (vec2 gridCoords) 1)) rayPos) rayDir)))\n          (=float dist (max t.x t.y))\n          (\"if\" (>= dist maxDist) (return :default-return-expression))\n          :column-hit-expression\n          (\"if\" (< tMax.x tMax.y)\n                (+= tMax.x delta.x)\n                (+= gridCoords.x step.x)\n                (= norm (vec3 (- \"0.0\" (float step.x)) 0 0)))\n          (\"else\" (+= tMax.y delta.y)\n                  (+= gridCoords.y step.y)\n                  (= norm (vec3 0 (- \"0.0\" (float step.y)) 0))))\n         :default-return-expression)}}})))\n\n; based on https://iquilezles.org/articles/intersectors/\n(def capsule-intersection-chunk\n  '{:functions\n    {findCapsuleDist\n     {([Ray vec3 vec3 float] float)\n      ([ray point1 point2 radius]\n       (=vec3 diff (- point2 point1))\n       (=vec3 offset (- ray.pos point1))\n\n       (=float baba (dot diff diff))\n       (=float bard (dot diff ray.dir))\n       (=float baoa (dot diff offset))\n       (=float rdoa (dot ray.dir offset))\n       (=float oaoa (dot offset offset))\n\n       (=float a (- baba (* bard bard)))\n       (=float b (- (* baba rdoa) (* baoa bard)))\n       (=float c (- (* baba oaoa)\n                    (+ (* baoa baoa)\n                       (* radius radius baba))))\n       (=float h (- (* b b) (* a c)))\n       (\"if\" (>= h 0)\n             (=float t (/ (- 0 (+ b (sqrt h))) a))\n             (=float y (+ baoa (* t bard)))\n             (\"if\" (&& (> y 0) (< y baba)) (return t))\n             (=vec3 oc (if (<= y 0)\n                         offset\n                         (- ray.pos point2)))\n             (= b (dot ray.dir oc))\n             (= c (- (dot oc oc) (* radius radius)))\n             (= h (- (* b b) c))\n             (\"if\" (> h 0) (return (- 0 (+ b (sqrt h))))))\n       -1)}\n     capsuleNorm\n     {([vec3 vec3 vec3 float] vec3)\n      ([pos point1 point2 radius]\n       (=vec3 diff (- point2 point1))\n       (=vec3 offset (- pos point1))\n       (=float h (clamp (/ (dot offset diff)\n                           (dot diff diff))\n                        0\n                        1))\n       (/ (- offset (* h diff))\n          radius))}}})\n\n; based on https://iquilezles.org/articles/intersectors/\n(def cylinder-intersection-chunk\n  '{:structs\n    {CylinderIntersection [hit bool\n                           dist float\n                           norm vec3]}\n    :functions\n    {findCylinderIntersection\n     {([Ray vec3 vec3 float] CylinderIntersection)\n      ([ray point1 point2 radius]\n       (=vec3 diff (- point2 point1))\n       (=vec3 offset (- ray.pos point1))\n\n       (=float baba (dot diff diff))\n       (=float bard (dot diff ray.dir))\n       (=float baoc (dot diff offset))\n\n       (=float k2 (- baba (* bard bard)))\n       (=float k1 (- (* baba (dot offset ray.dir))\n                     (* baoc bard)))\n       (=float k0 (- (* baba (dot offset offset))\n                     (+ (* baoc baoc)\n                        (* radius\n                           radius\n                           baba))))\n\n       (=float h (- (* k1 k1) (* k2 k0)))\n       (\"if\" (< h 0)\n             (return (CylinderIntersection \"false\"\n                                           0\n                                           (vec3 0))))\n       (= h (sqrt h))\n       (=float t (/ (- 0 (+ k1 h)) k2))\n\n       (=float y (+ baoc (* t bard)))\n       (\"if\" (&& (>= t 0) (> y 0) (< y baba))\n             (return (CylinderIntersection \"true\"\n                                           t\n                                           (/ (- (+ offset (* t ray.dir))\n                                                 (/ (* diff y) baba))\n                                              radius))))\n\n       (= t (/ (- (if (< y 0) 0 baba) baoc) bard))\n       (\"if\" (&& (>= t 0)\n                 (< (abs (+ k1 (* k2 t))) h))\n             (return (CylinderIntersection \"true\"\n                                           t\n                                           (/ (* diff (sign y))\n                                              (sqrt baba)))))\n\n       (CylinderIntersection \"false\"\n                             0\n                             (vec3 0)))}}})\n"]}