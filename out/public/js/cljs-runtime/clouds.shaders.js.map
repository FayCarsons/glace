{"version":3,"sources":["clouds/shaders.cljs"],"mappings":"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","names":["clouds.shaders/u32-max","clouds.config/u32-max","clouds.shaders/u32-max-u","clouds.shaders/header","cljs.core.partial","sprog.iglu.core/iglu->glsl","clouds.shaders/render-frag","clojure.walk/prewalk-replace","iter__5520__auto__","s__34758","cljs.core/LazySeq","temp__5804__auto__","cljs.core/seq","xs__6360__auto__","cljs.core/first","iterys__5516__auto__","s__34760","cljs.core/chunked-seq?","c__5518__auto__","size__5519__auto__","cljs.core/count","b__34762","cljs.core/chunk-buffer","i__34761","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__34759","cljs.core/chunk-rest","cljs.core/cons","cljs.core/rest","fs__5517__auto__","cljs.core.concat","iter__34757","sprog.iglu.chunks.misc/pos-chunk","sprog.iglu.chunks.misc/bilinear-usampler-chunk","clouds.config/max-brightness","cljs.core.apply","cljs.core/concat","x","cljs.core.range","clouds.config/bilateral-kernel-size","y","clojure.walk/postwalk-replace","cljs.core.gensym","clouds.config/bilateral-color-sigma","Math/exp","clouds.config/bilateral-sigma","norm-pdf","clouds.shaders/trace-frag","sprog.iglu.chunks.misc/gradient-chunk","sprog.iglu.chunks.raytracing/sphere-intersection-chunk","sprog.iglu.chunks.raytracing/plane-intersection-chunk","sprog.iglu.chunks.raytracing/box-intersection-chunk","clouds.chunks/raymarch-chunk","clouds.intersections/raymarch-test-chunk","sprog.iglu.chunks.sdf/sphere-sdf-chunk","sprog.iglu.chunks.sdf/box-frame-sdf-chunk","sprog.iglu.chunks.sdf/box-sdf-chunk","sprog.iglu.chunks.noise/rand-normal-chunk","sprog.iglu.chunks.transformations/axis-rotation-chunk","sprog.iglu.chunks.sdf/twistX-chunk","sprog.iglu.chunks.sdf/twistY-chunk","sprog.iglu.chunks.sdf/smooth-subtraction-chunk","sprog.iglu.chunks.sdf/smooth-union-chunk","sprog.iglu.chunks.sdf/smooth-intersectioon-chunk","sprog.iglu.chunks.noise/simplex-3d-chunk","sprog.iglu.chunks.color/hsv-to-rgb-chunk","sprog.iglu.chunks.noise/pcg-hash-chunk","cljs.core.merge","clouds.config/materials-map","clouds.config/fudge-factor","clouds.config/sphere-octaves","Math/PI","clouds.config/rand-scale","clouds.config/skybox?","clouds.config/gold-light?","clouds.config/ambient-light-factor","clouds.config/sky-gold","clouds.config/sun-expression","clouds.config/cam-pos","clouds.config/bounce-loop-limit","clouds.config/max-steps","clouds.shaders/worley-frag","clouds.chunks/worley-chunk","sprog.iglu.chunks.noise/fbm-chunk","clouds.config/cloud-freq","cljs.core.rand","cljs.core/chunk-first"],"sourcesContent":["(ns clouds.shaders\n  (:require [sprog.util :as u]\n            [clouds.config :as c]\n            [clouds.chunks :refer [worley-chunk\n                                   raymarch-chunk]]\n            [clouds.intersections :as i]\n            [clojure.walk :refer [postwalk-replace]]\n            [sprog.iglu.core :refer [iglu->glsl\n                                     combine-chunks]]\n            [sprog.iglu.chunks.noise :refer [rand-normal-chunk\n                                             simplex-3d-chunk\n                                             pcg-hash-chunk\n                                             fbm-chunk]]\n            [sprog.iglu.chunks.raytracing :refer [sphere-intersection-chunk\n                                                  plane-intersection-chunk\n                                                  box-intersection-chunk]]\n            [sprog.iglu.chunks.sdf :refer [sphere-sdf-chunk\n                                           box-frame-sdf-chunk\n                                           box-sdf-chunk\n                                           twistX-chunk\n                                           twistY-chunk\n                                           smooth-union-chunk\n                                           smooth-intersectioon-chunk\n                                           smooth-subtraction-chunk]]\n            [sprog.iglu.chunks.transformations :refer [x-rotation-matrix-chunk\n                                                       y-rotation-matrix-chunk\n                                                       axis-rotation-chunk]]\n            [sprog.iglu.chunks.color :refer [hsv-to-rgb-chunk]]\n            [sprog.iglu.chunks.misc :refer [bilinear-usampler-chunk\n                                            pos-chunk\n                                            gradient-chunk]]\n            #_[fxrng.rng :refer [fxrand\n                               fxrand-int]]))\n\n(def u32-max c/u32-max)\n(def u32-max-u \"0xFFFFFFFFu\")\n\n(def header \n  (partial iglu->glsl\n           '{:version \"300 es\"\n             :precision {float highp\n                         int highp\n                         usampler2D highp\n                         sampler2D highp}}))\n\n(def render-frag\n (u/unquotable\n   (header\n    pos-chunk\n    bilinear-usampler-chunk\n    '{:outputs {fragColor vec4}\n      :uniforms {size vec2\n                 final usampler2D\n                 skybox usampler2D\n                 bilateral? bool}\n      :functions {aces-tonemap\n                  {([vec3] vec3)\n                   ([rgb]\n                    (clamp (/ (* rgb (+ 0.03 (* 2.51 rgb)))\n                              (+ 0.14 (* rgb (+ 0.59 (* 2.43 rgb)))))\n                           0\n                           1))}\n                  gamma-correction\n                  {([vec3] vec3)\n                   ([rgb]\n                    (pow rgb (vec3 (/ 1 2.2))))}\n                  pixel-color\n                  {([ivec2] vec3)\n                   ([coords]\n                    (-> final\n                        (texelFetch coords \"0\")\n                        .rgb\n                        vec3\n                        (/ ~u32-max)\n                        (* ~c/max-brightness)\n                        aces-tonemap))}\n                  normPDF\n                  {([vec3 float] float)\n                   ([x sigma]\n                    (* 0.39894\n                       (/ (exp (/ (* -0.5 (dot x x)) (* sigma sigma)))\n                          sigma)))}}\n      :main ((=vec3 center-color (pixel-color (ivec2 gl_FragCoord.xy)))\n             (\"if\" bilateral?\n                   (=float factor-sum 0)\n                   (=vec3 color-sum (vec3 0))\n                   ~(cons 'do\n                          (apply\n                           concat\n                           (for [x (range (- c/bilateral-kernel-size)\n                                          (inc c/bilateral-kernel-size))\n                                 y (range (- c/bilateral-kernel-size)\n                                          (inc c/bilateral-kernel-size))]\n                             (postwalk-replace\n                              {:other-color (gensym \"other-color\")\n                               :color-diff (gensym \"color-diff\")\n                               :factor (gensym \"factor\")}\n                              '((=vec3 :other-color\n                                       (pixel-color (+ (ivec2 gl_FragCoord.xy)\n                                                       (ivec2 ~(str x)\n                                                              ~(str y)))))\n                                (=float :factor\n                                        (* (normPDF (- :other-color \n                                                       center-color)\n                                                    ~c/bilateral-color-sigma)\n                                           ~(letfn\n                                             [(norm-pdf [x]\n                                                (* 0.39894\n                                                   (/ (Math/exp\n                                                       (/ (* -0.5 x x)\n                                                          (* c/bilateral-sigma\n                                                             c/bilateral-sigma)))\n                                                      c/bilateral-sigma)))]\n                                              (* (norm-pdf x)\n                                                 (norm-pdf y)))))\n                                (+= factor-sum :factor)\n                                (+= color-sum (* :factor :other-color)))))))\n                   (= fragColor (vec4 (gamma-correction (/ color-sum factor-sum))\n                                      1)))\n             (\"else\"\n              (= fragColor (vec4 (gamma-correction center-color)\n                                 1))))})))\n\n\n\n(def trace-frag\n  (u/unquotable\n   (header\n    pos-chunk\n    bilinear-usampler-chunk\n    gradient-chunk\n\n    sphere-intersection-chunk\n    plane-intersection-chunk\n    box-intersection-chunk\n\n    raymarch-chunk\n    i/raymarch-test-chunk\n    sphere-sdf-chunk\n    box-frame-sdf-chunk\n    box-sdf-chunk\n    rand-normal-chunk\n    axis-rotation-chunk\n    twistX-chunk\n    twistY-chunk\n    smooth-subtraction-chunk\n    smooth-union-chunk\n    smooth-intersectioon-chunk\n\n    \n\n    simplex-3d-chunk\n    hsv-to-rgb-chunk\n    pcg-hash-chunk\n    '{:constants ~(merge {}\n                         c/materials-map)\n      :defines {(fudge x) (* x ~c/fudge-factor)}\n      :outputs {Color uvec4\n                Position uvec4\n                Direction uvec4\n                Accumulated uvec4\n                Attenuation uvec4\n                Meta uvec4}\n      :layout {Color 0\n               Position 1\n               Direction 2\n               Accumulated 3\n               Attenuation 4\n               Meta 5}\n      :uniforms {size vec2\n                 camera mat3\n                 rand-offset vec3\n                 ray-pos-tex usampler2D\n                 ray-dir-tex usampler2D\n                 color-tex usampler2D\n                 accumulation-tex usampler2D\n                 attenuation-tex usampler2D\n                 ray-meta-tex usampler2D\n                 skybox usampler2D\n                 frame float\n                 sphere-angles [float ~(str c/sphere-octaves)]\n                 sphere-axes [vec3 ~(str c/sphere-octaves)]}\n      :structs {Ray\n                [pos vec3\n                 dir vec3\n                 color vec3\n                 attenuation vec3]\n                Sphere\n                [pos vec3\n                 radius float\n                 material Material]\n                Plane\n                [pos vec3\n                 normal vec3\n                 material Material]\n                Material\n                [type int\n                 albedo vec3\n                 specular vec3\n                 emissive vec3\n                 roughness float\n                 ior float]\n                Record\n                [hit bool\n                 distance float\n                 point vec3\n                 normal vec3\n                 material Material]}\n      :functions\n      {hemisphere-uniform\n       {([vec3] vec4)\n        ([normal]\n         (=vec3 rand-vec (rand-pcg (+ rand-offset\n                                      normal\n                                      gl_FragCoord.xyz)))\n         (=float cos-theta rand-vec.x)\n         (=float sin-theta (sqrt (- 1 (* cos-theta cos-theta))))\n\n         (=float phi (* 2\n                        ~Math/PI\n                        rand-vec.y))\n         ;\"spherical to cartesian\"\n         (=vec3 t (normalize (cross normal.yzx normal)))\n         (=vec3 b (cross normal t))\n         (vec4 (+ (* sin-theta\n                     (+ (* t\n                           (cos phi))\n                        (* b\n                           (sin phi))))\n                  (* normal\n                     cos-theta))\n               1))}\n\n       hemisphere-cosine\n       {([vec3] vec4)\n        ([normal]\n         (=vec3 rand-vec (rand-pcg (+ rand-offset\n                                      normal\n                                      gl_FragCoord.xyz)))\n         (=float cos-theta rand-vec.x)\n         (=float sin-theta (sqrt (- 1 (* cos-theta cos-theta))))\n\n         (=float phi (* 2\n                        ~Math/PI\n                        rand-vec.y))\n         ;\"spherical to cartesian\"\n         (=vec3 t (normalize (cross normal.yzx normal)))\n         (=vec3 b (cross normal t))\n\n         (=vec3 l (+ (* sin-theta\n                        (+ (* t\n                              (cos phi))\n                           (* b\n                              (sin phi))))\n                     (* normal\n                        cos-theta)))\n         (=float pdf (* ~(/ Math/PI)\n                        cos-theta))\n         (vec4 l (/ ~(/ 0.5 Math/PI)\n                    (+ pdf 1e-6))))}\n\n       hemisphere-ggx\n       {([vec3 vec3 float] vec4)\n        ([normal v roughness]\n         (=float temp (* roughness roughness))\n         (=float alpha (* temp temp))\n\n         (=vec3 rand-vec (rand-pcg (+ rand-offset\n                                      normal\n                                      gl_FragCoord.xyz)))\n\n         (=float epsilon (clamp rand-vec.x 0.001 1))\n         (=float cos-theta2 (/ (- 1 epsilon)\n                               (+ (* epsilon (- alpha 1))\n                                  1)))\n         (=float cos-theta (sqrt cos-theta2))\n         (=float sin-theta (sqrt (- 1 cos-theta2)))\n\n         (=float phi (* 2\n                        ~Math/PI\n                        rand-vec.y))\n\n         ;\"spherical to cartesian\"\n         (=vec3 t (normalize (cross normal.yzx normal)))\n         (=vec3 b (cross normal t))\n\n         (=vec3 micro-normal\n                (+ (* t\n                      (cos phi))\n                   (* b\n                      (sin phi)\n                      sin-theta)\n                   (* normal cos-theta)))\n         (=vec3 l (reflect \"-v\" micro-normal))\n\n         ;\"sample weight\"\n         (=float den (* (- alpha 1)\n                        (+ cos-theta2 1)))\n         (=float d (/ alpha\n                      (* ~Math/PI\n                         den\n                         den)))\n         (=float pdf (/ (* d cos-theta)\n                        (* 4\n                           (dot micro-normal\n                                v))))\n\n         (=float weight (if (< (dot l normal) 0)\n                          0\n                          (/ ~(/ 0.5 Math/PI)\n                             (+ pdf 1e-6))))\n\n         (vec4 l weight))}\n\n       ggx\n       {([vec3 vec3 vec3 float vec3] vec3)\n        ([normal dir reflected roughness specular]\n         (=float temp (* roughness roughness))\n         (=float alpha (* temp temp))\n\n         (=float dot-normal (clamp (dot normal reflected) 0 1))\n         (=float dot-dir (clamp (dot normal dir) 0 1))\n\n         (=vec3 h (normalize (+ dir reflected)))\n\n         (=float dot-normal-h (clamp (dot normal h) 0 1))\n         (=float dot-reflected-h (clamp (dot reflected h) 0 1))\n\n         ;GGX microfacet distribution function\n         (=float den (+ (* (- alpha 1)\n                           dot-normal-h\n                           dot-normal-h)\n                        1))\n         (=float density (/ alpha (* ~Math/PI\n                                     den\n                                     den)))\n\n         ;fresnel with schlick approximation\n         (=vec3 fresnel (+ specular\n                           (* (- 1 specular)\n                              (pow (- 1 dot-reflected-h) 5))))\n\n         ;Smith joint masking-shadowing fn \n         (=float k (* 0.5 alpha))\n         (=float g (/ (* (+ k\n                            (* dot-normal\n                               (- 1 k)))\n                         (+ k\n                            (* dot-dir\n                               (- 1 k))))))\n         (* density fresnel g))}\n\n       ray-at\n       {([Ray float] vec3)\n        ([ray distance]\n         (+ ray.pos (* ray.dir\n                       distance)))}\n\n       reflect-ray\n       {([Ray Record] Ray)\n        ([ray record]\n         (=vec3 attenuation ray.attenuation)\n         (=float cos-theta-i (dot ray.dir record.normal))\n         (=vec3 facing-normal (if (< cos-theta-i 0)\n                                record.normal\n                                (- record.normal)))\n         (=vec3 collected-color (+ ray.color\n                                   (* ray.attenuation\n                                      record.material.emissive)))\n\n         (=vec3 outgoing-dir (vec3 0))\n\n         (\"if\" (== record.material.type\n                   :lambertian)\n               (=vec4 dir-sample (hemisphere-cosine\n                                  facing-normal))\n               (= outgoing-dir dir-sample.xyz)\n               (*= attenuation dir-sample.w)\n               (*= attenuation (* record.material.albedo\n                                  (dot facing-normal\n                                       outgoing-dir))))\n         (\"else if\" (== record.material.type :blinn-phong)\n                    (=vec4 dir-sample (hemisphere-cosine\n                                       facing-normal))\n                    (= outgoing-dir dir-sample.xyz)\n                    (=vec3 h (normalize (+ (- ray.dir)\n                                           outgoing-dir)))\n                    (*= attenuation dir-sample.w)\n                    (*= attenuation (+ (* record.material.albedo\n                                          (dot facing-normal\n                                               outgoing-dir))\n\n                                       (* record.material.specular\n                                          (pow (max (dot facing-normal\n                                                         h)\n                                                    0)\n                                               record.material.roughness)))))\n         (\"else if\" (== record.material.type\n                        :specular)\n                    (= outgoing-dir (reflect ray.dir facing-normal))\n                    (*= attenuation record.material.specular))\n         (\"else if\" (== record.material.type\n                        :dielectric)\n                    (=float eta (if (< cos-theta-i 0)\n                                  (/ record.material.ior)\n                                  record.material.ior))\n                    (=vec3 refracted (refract ray.dir facing-normal eta))\n\n                    (\"if\" (all (equal refracted (vec3 0)))\n                          (= outgoing-dir (reflect ray.dir facing-normal)))\n                    (\"else\"\n                     ;fresnel with schlick approximation\n                     (=float temp (/ (- record.material.ior 1)\n                                     (+ 1 record.material.ior)))\n                     (=float pre-fres (* temp temp))\n                     (=float cos-theta (if (< cos-theta-i 0)\n                                         (- cos-theta-i)\n                                         (dot refracted record.normal)))\n                     (=float fresnel (+ pre-fres (* (- 1 pre-fres)\n                                                    (pow (- 1 cos-theta)\n                                                         5))))\n\n                     (\"if\" (< (.x (rand-pcg (+ rand-offset\n                                               gl_FragCoord.xyz\n                                               (* ray.pos\n                                                  ~c/rand-scale))))\n                              fresnel)\n                           (= outgoing-dir (reflect ray.dir facing-normal)))\n                     (\"else\"\n                      (*= attenuation record.material.albedo)\n                      (= outgoing-dir refracted))))\n         (\"else if\" (== record.material.type :lommel)\n                    (*= attenuation record.material.albedo)\n                    (= outgoing-dir (-> facing-normal\n                                        hemisphere-uniform\n                                        .xyz)))\n         (\"else if\" (== record.material.type\n                        :ggx)\n                    (=vec4 dir-sample (vec4 1))\n                    (\"if\" (&& (> (length record.material.albedo)\n                                 0.04)\n                              (< (.x (rand-pcg (+ rand-offset\n                                                  gl_FragCoord.xyz\n                                                  (* ray.pos\n                                                     ~c/rand-scale))))\n                                 0.5))\n                          (= dir-sample (hemisphere-cosine facing-normal))\n                          (= outgoing-dir dir-sample.xyz)\n                          (*= attenuation dir-sample.w)\n                          (*= attenuation (* record.material.albedo\n                                             (dot facing-normal\n                                                  outgoing-dir))))\n                    (\"else\"\n                     (= dir-sample (hemisphere-ggx facing-normal\n                                                   (- ray.dir)\n                                                   record.material.roughness))\n                     (= outgoing-dir dir-sample.xyz)\n                     (*= attenuation dir-sample.w)\n                     (*= attenuation (* (dot facing-normal\n                                             outgoing-dir)\n                                        (ggx facing-normal\n                                             (- ray.dir)\n                                             outgoing-dir\n                                             record.material.roughness\n                                             record.material.specular)))))\n         (Ray (+ record.point\n                 (fudge outgoing-dir))\n              outgoing-dir\n              (+ ray.color\n                 collected-color)\n              attenuation))}\n       exit-color\n       {([Ray] vec3)\n        ([ray]\n         (+ ~(if c/skybox?\n               '(-> skybox\n                    (textureBilinear (bi->uni ray.dir.xy))\n                    .rgb\n                    vec3\n                    (/ ~u32-max))\n               '0)\n            (* (smoothstep -2\n                           1\n                           (dot ray.dir\n                                (vec3 0)))\n               ~(if c/gold-light?\n                  '(* ~c/ambient-light-factor\n                      ~c/sky-gold)\n                  '(vec3 ~c/ambient-light-factor)))\n            ~c/sun-expression))}}\n      :main ((=vec2 pos (+ (getPos)\n                           (* 0.05\n                              (/ size))))\n             (=ivec2 frag-pos (ivec2 gl_FragCoord.xy))\n\n             (=uvec4 meta-color\n                     (texelFetch ray-meta-tex frag-pos \"0\"))\n             (=int step (int meta-color.x))\n             (=int accumulation-index (int meta-color.y))\n\n             (=bool ray-finished false)\n\n             (=vec3 old-accumulated (-> accumulation-tex\n                                        (texelFetch frag-pos \"0\")\n                                        .xyz\n                                        vec3\n                                        (/ ~u32-max)))\n\n             (=Ray ray\n                   (Ray (if (== step \"0\")\n                          ~(cons 'vec3 c/cam-pos)\n                          (-> ray-pos-tex\n                              (texelFetch frag-pos \"0\")\n                              .xyz\n                              vec3\n                              (/ ~u32-max)\n                              uni->bi))\n                        (if (== step \"0\")\n                          (-> pos\n                              (* 2)\n                              (- 1)\n                              (vec3 1)\n                              normalize)\n                          (-> ray-dir-tex\n                              (texelFetch frag-pos \"0\")\n                              .xyz\n                              vec3\n                              (/ ~u32-max)\n                              uni->bi))\n                        (if (== step \"0\")\n                          (vec3 0)\n                          (-> color-tex\n                              (texelFetch frag-pos \"0\")\n                              .xyz\n                              vec3\n                              (/ ~u32-max)))\n                        (if (== step \"0\")\n                          (vec3 1)\n                          (-> attenuation-tex\n                              (texelFetch frag-pos \"0\")\n                              .xyz\n                              vec3\n                              (/ ~u32-max)))))\n             (~(str \"for(int s=0;s<\" c/bounce-loop-limit \";s++)\")\n              (=Record record (hit-world ray))\n\n              (\"if\" record.hit\n\n                    (= ray (reflect-ray ray record))\n                    (+= step \"1\")\n                    (\"if\" (> step ~(str c/max-steps))\n                          (= ray-finished true)\n                          (= ray.color (vec3 0))\n                          \"break\"))\n\n              (\"else\"\n               (+= ray.color\n                   (* ray.attenuation (exit-color ray)))\n               (= ray-finished true)\n               \"break\"))\n\n             (= Color (uvec4 (uvec3 (* ray.color\n                                       ~u32-max))\n                             ~u32-max-u))\n             (= Position (uvec4 (uvec3 (* (-> ray.pos\n                                              bi->uni)\n                                          ~u32-max))\n                                ~u32-max-u))\n             (= Direction (uvec4 (uvec3 (* (-> ray.dir\n                                               bi->uni)\n                                           ~u32-max))\n                                 ~u32-max-u))\n             (= Accumulated (uvec4\n                             (uvec3\n                              (* (if ray-finished\n                                   (clamp\n                                    (mix old-accumulated\n                                         (/ ray.color\n                                            ~c/max-brightness)\n                                         (/ 1 (+ 1\n                                                 (float accumulation-index))))\n                                    0 1)\n                                   old-accumulated)\n                                 ~u32-max))\n                             ~u32-max-u))\n             (= Attenuation (uvec4 (* ray.attenuation\n                                      ~u32-max)\n                                   ~u32-max-u))\n             (= Meta (uvec4 (if ray-finished\n                              \"0\"\n                              step)\n                            (if ray-finished\n                              (+ accumulation-index \"1\")\n                              accumulation-index)\n                            0\n                            0)))})))\n\n(def worley-frag\n  (u/unquotable\n   (header\n    worley-chunk\n    fbm-chunk\n    pcg-hash-chunk\n    simplex-3d-chunk\n    '{:outputs {fragColor uvec4}\n      :uniforms {size vec2\n                 frame float}\n      :main ((=vec2 pos (/ gl_FragCoord.xy size))\n             (=float worley-fbm (fbm worley-noise\n                                     3\n                                     (vec3 (+ (* pos\n                                                 ~c/cloud-freq)\n                                              (* 0.025\n                                                 (snoise3D (vec3 (* pos 20)\n                                                                 ~(rand 1000)))))\n                                           ~(rand 1000))\n                                     \"5\"\n                                     0.75))\n             (= fragColor (uvec4 (* (mix (vec3 0.129 0.3078 0.9213)\n                                         (vec3 1)\n                                         (-> (- 1 worley-fbm)\n                                             (- 0.3)\n                                             (/ 0.7)\n                                             (max 0)))\n                                    ~u32-max)\n                                 (uvec3 \"0u\"))))})))"]}