{"version":3,"sources":["clouds/shaders.cljs"],"mappings":";AAaA,AAAKA,yBAAQ,AAACC,WAAWC;AACzB,AAAKC,2BAAU,qEAAA,xBAAKH;AAEpB,wBAAA,AAAA,xBAAKI;AAOL,2BAAA,AAAA,3BAAKC;AAOL,AAAKC,6BACJ,AAAA,2NAAA,AAAAC,6BAAA,2CAAA,6FAAA,AAAA,hYACGC,mEACAJ,wEACAK,iCACAC,qLAWoCV;AAGxC,mCAAA,AAAA,nCAAKW;AA0DL,AAAKC,4BACH,AAAA,qVAAA,AAAAL,6BAAA,wCAAA,6DAAA,6DAAA,4DAAA,8DAAA,8DAAA,4DAAA,6DAAA,6DAAA,6DAAA,6DAAA,4DAAA,6DAAA,4DAAA,8DAAA,6DAAA,6DAAA,oHAAA,CAAA,+FAAA,8SAAA,qGAAA,AAAA,h9DACEC,mEACAJ,wEACAK,iCACAI,uCACAC,uDACAC,0CACAJ,ozCAyD6BK,+FAeWhB,uBAIjBiB,9FAKOjB,uTAaAA,vQASKA,rJAGFkB,lHAwBCC,2aAaEnB,zBACVG,vEAEaH,rKACVG,4LAEWH,pHACVG,jNAWAH,4VACJG,qHAISiB","names":["clouds.shaders/u32-max","Math/floor","clouds.config/u32-max","clouds.shaders/u32-max-u","clouds.shaders/header","clouds.shaders/rot-chunk","clouds.shaders/render-frag","clojure.walk/prewalk-replace","sprog.iglu.core.iglu__GT_glsl","sprog.iglu.chunks.misc/pos-chunk","sprog.iglu.chunks.misc/bilinear-usampler-chunk","clouds.shaders/test-intersection","clouds.shaders/trace-frag","sprog.iglu.chunks.raytracing/ray-chunk","sprog.iglu.chunks.raytracing/sphere-intersection-chunk","sprog.iglu.chunks.noise/rand-sphere-chunk","clouds.config/light-pos","clouds.config/cam-pos","clouds.config/bounces-per-sample","clouds.config/scatter-radius","clouds.config/steps-per-sample"],"sourcesContent":["(ns clouds.shaders\n  (:require [sprog.util :as u]\n            [clouds.config :as c]\n            [sprog.iglu.core :refer [iglu->glsl\n                                     combine-chunks]]\n            [sprog.iglu.chunks.noise :refer [rand-sphere-chunk]]\n            [sprog.iglu.chunks.raytracing :refer [ray-chunk\n                                                  sphere-intersection-chunk]]\n            [sprog.iglu.chunks.misc :refer [bilinear-usampler-chunk\n                                            pos-chunk]]\n            #_[fxrng.rng :refer [fxrand\n                               fxrand-int]]))\n\n(def u32-max (Math/floor c/u32-max))\n(def u32-max-u (str u32-max \"u\"))\n\n(def header \n  '{:version \"300 es\"\n    :precision {float highp \n                int highp \n                usampler2D highp \n                sampler2D highp}})\n\n(def rot-chunk \n  '{:functions {rot \n                {([float] mat2)\n                 ([angle]\n                  (mat2 (cos angle) \"-sin(angle)\"\n                        (sin angle) (cos angle)))}}})\n\n(def render-frag\n (u/unquotable\n   (iglu->glsl\n    header\n    pos-chunk\n    bilinear-usampler-chunk\n    '{:outputs {fragColor vec4}\n      :uniforms {size vec2\n                 now float\n                 atlas usampler2D\n                 final usampler2D}\n      :main ((=vec2 pos (getPos))\n             (= fragColor (vec4 (-> final \n                                    (textureBilinear pos)\n                                    .xyz \n                                    vec3 \n                                    (/ ~u32-max))\n                                1)))})))\n\n(def test-intersection \n  '{:functions\n    {hit-world\n     {([Ray] Record)\n      ([ray]\n       (=vec3 color (vec3 0))\n       (=Record record (Record \"false\"\n                               1024\n                               (vec3 0)\n                               (vec3 0)\n                               \"0\"))\n       (=Sphere center-sphere (Sphere (vec3 0 0 -2)\n                                      1\n                                      \"0\"))\n       (=Sphere side-sphere (Sphere (vec3 1 0 -1)\n                                    0.1\n                                    \"1\"))\n\n       (=float sphere-distance (.x\n                                (findSphereIntersections ray\n                                                         center-sphere.pos\n                                                         center-sphere.radius)))\n       (=bool hit-sphere (> sphere-distance 0))\n       (\"if (hit_sphere)\"\n        (= record.hit \"true\")\n        (= record.distance sphere-distance)\n        (= record.point (ray-point ray sphere-distance))\n        (= record.normal (normalize (/ (- record.point\n                                          center-sphere.pos)\n                                       center-sphere.radius)))\n        (=bool front-face (> (dot ray.dir record.normal) 0))\n          ; set normals to always face outward\n        (= record.normal (if (! front-face)\n                           record.normal\n                           (- 0 record.normal)))\n        (= record.id center-sphere.id))\n       (\"else\"\n        (= sphere-distance (.x (findSphereIntersections ray\n                                                        side-sphere.pos\n                                                        side-sphere.radius)))\n        (= hit-sphere (> sphere-distance 0))\n        (\"if (hit_sphere)\"\n         (= record.hit \"true\")\n         (= record.distance sphere-distance)\n         (= record.point (ray-point ray sphere-distance))\n         (= record.normal (normalize (/ (- record.point\n                                           side-sphere.pos)\n                                        2)))\n         (=bool front-face (> (dot ray.dir record.normal) 0))\n          ; set normals to always face outward\n         (= record.normal (if (! front-face)\n                            record.normal\n                            (- 0 record.normal)))\n         (= record.id side-sphere.id)))\n\n       record)}}})\n\n\n(def trace-frag\n  (u/unquotable\n   (iglu->glsl\n    header\n    pos-chunk\n    ray-chunk\n    sphere-intersection-chunk\n    rand-sphere-chunk\n    test-intersection\n    '{:outputs {Color uvec4\n                Position uvec4\n                Direction uvec4\n                Accumulated uvec4\n                Meta uvec4}\n      :layout {Color 0\n               Position 1\n               Direction 2\n               Accumulated 3\n               Meta 4}\n      :uniforms {size vec2\n                 rand-offset vec3\n                 ray-pos-tex usampler2D\n                 ray-dir-tex usampler2D\n                 color-tex usampler2D\n                 accumulation-tex usampler2D\n                 ray-meta-tex usampler2D\n                 frame float}\n      :structs {Sphere\n                [pos vec3\n                 radius float\n                 id int]\n                \n                Record\n                [hit bool\n                 distance float\n                 point vec3\n                 normal vec3\n                 id int]}\n      :functions\n      {aces-tonemap\n       {([vec3] vec3)\n        ([rgb]\n         (clamp (/ (* rgb (+ 0.03 (* 2.51 rgb)))\n                   (+ 0.14 (* rgb (+ 0.59 (* 2.43 rgb)))))\n                0\n                1))}\n       gamma-correction\n       {([vec3] vec3)\n        ([rgb]\n         (pow rgb (vec3 (/ 1 2.2))))}\n       ray-point\n       {([Ray float] vec3)\n        ([ray distance]\n         (+ ray.pos (* ray.dir distance)))}\n       exit-color\n       {([vec3] vec3)\n        ([ray-dir]\n         (+ (mix (vec3 0.5 0.7 1)\n              (vec3 1)\n              (-> ray-dir.y\n                  (+ 1)\n                  (* 0.5)))\n            (* (smoothstep 0.9\n                           0.95\n                           (dot ray-dir\n                                ~c/light-pos))\n               (vec3 1)))\n         )}}\n      :main ((=vec2 pos (getPos))\n             (=uvec4 meta-color\n                     (texelFetch ray-meta-tex (ivec2 gl_FragCoord.xy) \"0\"))\n             (=int step (int meta-color.x))\n             (=int accumulation-index (int meta-color.y))\n\n             (=bool ray-finished \"false\")\n\n             (=vec3 old-accumulated (-> accumulation-tex\n                                        (texelFetch (ivec2 gl_FragCoord.xy) \"0\")\n                                        .xyz\n                                        vec3\n                                        (/ ~u32-max)))\n\n             (=Ray ray\n                   (Ray (if (== step \"0\")\n                          ~c/cam-pos\n                          (-> ray-pos-tex\n                              (texelFetch (ivec2 gl_FragCoord.xy) \"0\")\n                              .xyz\n                              vec3\n                              (/ ~u32-max)))\n\n                        (if (== step \"0\")\n                          (-> pos\n                              (* 2)\n                              (- 1)\n                              (vec3 -1)\n                              normalize)\n\n                          (-> ray-dir-tex\n                              (texelFetch (ivec2 gl_FragCoord.xy) \"0\")\n                              .xyz\n                              vec3\n                              (/ ~u32-max)))))\n\n             (=vec3 in-color (if (== step \"0\")\n                               (vec3 1)\n\n                               (-> color-tex\n                                   (texelFetch (ivec2 gl_FragCoord.xy) \"0\")\n                                   .xyz\n                                   vec3\n                                   (/ ~u32-max))))\n\n             (=vec3 ray-color in-color)\n             (~(str \"for(int s=0;s<\" c/bounces-per-sample \";s++)\")\n\n              (=Record record (hit-world ray))\n\n              (\"if (record.hit)\"\n               (= ray-color (* ray-color\n                               (if (== record.id \"0\")\n                                 (vec3 1 0.5 0.5)\n                                 (vec3 0.5 1 0.5))))\n               (=vec3 reflected-dir (reflect ray.dir\n                                             record.normal))\n               (= ray (Ray record.point\n                           (normalize\n                            (- (+ record.point\n                                  reflected-dir\n                                  (* (randSphere\n                                      (+ (* 100\n                                            (vec3 gl_FragCoord.xy\n                                                  (- gl_FragCoord.x \n                                                     (* gl_FragCoord.y 0.25)\n                                                     100)))\n                                         #_(* 200\n                                              gl_FragCoord.xyz)\n                                         rand-offset))\n                                     ~c/scatter-radius))\n                               record.point)))))\n              (\"else\"\n               (= ray-color (* ray-color\n                               (exit-color ray.dir)))\n               (= ray-finished \"true\")\n               \"break\"))\n\n             (=vec3 out-color ray-color)\n             (=vec3 out-position ray.pos)\n             (=vec3 out-direction ray.dir)\n\n             (= Color (uvec4 (uvec3 (* out-color\n                                       ~u32-max))\n                             ~u32-max-u))\n             (= Position (uvec4 (uvec3 (* ray.pos\n                                          ~u32-max))\n                                ~u32-max-u))\n             (= Direction (uvec4 (uvec3 (* ray.dir\n                                           ~u32-max))\n                                 ~u32-max-u))\n             (= Accumulated (uvec4\n                             (uvec3\n                              (* (if ray-finished\n                                  (clamp\n                                   (mix old-accumulated\n                                        out-color\n                                        (/ 1 (+ 1\n                                                (float accumulation-index))))\n                                   0 1)\n                                   old-accumulated)\n                                 ~u32-max))\n                             ~u32-max-u))\n             (= Meta (uvec4 (if ray-finished\n                              \"0\"\n                              (+ step \n                                 ~(str c/steps-per-sample)))\n                            (if ray-finished\n                              (+ accumulation-index \"1\")\n                              accumulation-index)\n                            0\n                            0)))})))"]}