{"version":3,"sources":["clouds/shaders.cljs"],"mappings":";AA4BA,AAAKA,yBAAQ,AAACC,WAAWC;AACzB,AAAKC,2BAAU,qEAAA,xBAAKH;AAEpB,AAAKI,wBACH,8EAAA,AAAA,9EAACC,gDAAQC;AA0BX,AAAKC,8BACH,AAAA,AAAAC,6BAAA,mCAAA,AAAA;AAyBF,AAAKC,6BACJ,AAAA,sGAAA,AAAAD,6BAAA,2CAAA,2DAAA,iBAAAE,1PACGN,sBACAQ,iCACAC,8MAmBuBC;IAtB1BJ,eAAA,EAAA,CAAAA,oBAAAC,oBAAA,AAAAD,aAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAF,6BAAA,2CAAA,6FAAA,AAAA,/BA2BuCR;;;;AA3BvC,OAAAQ,6BAAA,2CAAA,qFAAA,kGAAA,AAAA,zHAkC+BR,oFACAe;;;aAnC/B,AAAA;AA6JD,AAAKC,iCACH,AAAA,AAAAR,6BAAA,2CAAA,mGAAA,AAAA,rCAKwBS;AAE1B,AAAKC,mCACH,AAAA,AAAAV,6BAAA,2CAAA,6FAAA,4FAAA,mFAAA,4DAAA,eAAA,AAAA,qDAAA,4CAAA,1XAS8BY,4FAGAA,2FACApB,mFAEvBqB,oEACMC,uDACKC,EAAEC;AAjBpB,AAAA,eAAA,eAAA,AAAA,1BAkBqBC,WAAUJ,uEAAWG;AAlB1C,AAAA,OAAAhB,6BAAA,2CAAA,6DAAA,EAAA,EAAA,8BAAA,CAAA,iDAAA,QAAA,AAAAA,6BAAA,2CAAA,sEAAA,sEAAA,iGAAA,AAAA,8uCAAA,AAAAA,6BAAA,2CAAA,+EAAA,AAAA,8IAAA,6DAAA,EAAA,0BAAA,sCAAA,AAAAW,mDAAA,IAAA,tlEAqBqCO,sBAAMH,SACHI,8LACAF,sEACGA,sEACGG,w5CAOTH,8NAELC,sBAAMH,IACRM;AAnC9B,AAAA,oDAAA,7CAmCkEF;2CAnClE,AAAA,tCAqC6BG;GArC7B,gHAAA,iGAAA,AAAA,jNAqDcC,8CAAMC,iCACPC,6FAMwBH;AAiBvC,AAAKI,4BACH,AAAA,8pBAAA,AAAA1B,6BAAA,wCAAA,8DAAA,6DAAA,4DAAA,8DAAA,8DAAA,8DAAA,4DAAA,8DAAA,2DAAA,4DAAA,4DAAA,6DAAA,6DAAA,6DAAA,6DAAA,8DAAA,2DAAA,8DAAA,6DAAA,4DAAA,8DAAA,4DAAA,8DAAA,8DAAA,6DAAA,4DAAA,8DAAA,2DAAA,4DAAA,6DAAA,8DAAA,6DAAA,gHAAA,CAAA,eAAA,+BAAA,AAAAA,6BAAA,2CAAA,2FAAA,AAAA,ymBAAA,AAAA,gIAAA,CAAA,8FAAA,kBAAA,mCAAA,AAAAA,6BAAA,2CAAA,gGAAA,4FAAA,AAAA,6LAAA,AAAAA,6BAAA,2CAAA,uGAAA,AAAA,iNAAA,qFAAA,CAAA,sCAAA,uGAAA,4QAAA,CAAA,wDAAA,AAAA,zqKACEJ,sBACAQ,iCACAC,+CACAsB,sCAEAC,uDACAC,sDACAC,oDAEAC,4CACAC,uCACAC,0CACAC,oCAEAC,sDAEAzB,iCAEA0B,yCACAC,yCACAC,soIACeC,0IACMC,t1CACOC,qpCA4DPC,2VAuBAA,sFAaGA,1ZAEAA,0bAoBHA,QAoBCA,v6EAUWA,s9DAuBCA,38DA8JrBC,iKAKOnD,23BAMJoD,sKACGC,gGACAC,gWACGD,rsDAIkBE,g4EAE5BC,1VAe4BxD,gOAIjByD,0LAKOzD,pKAYAA,6HAQAA,hDAOAA,/zCACG0D,m8BAOGC,xhCAYA3D,47BACVG,ybAGaH,ldACVG,2bAGWH,v3CACVG,6yCAOWY,p0CAKXf,74BACJG,k5DAESH,9hCACHG;AAUpC,AAAKyD,6BACH,AAAA,oKAAA,AAAApD,6BAAA,2CAAA,sFAAA,8DAAA,6CAAA,QAAA,6DAAA,6CAAA,QAAA,4FAAA,AAAA,noBACEJ,sBACAG,4BACAsD,kCACAf,uCACAF,8KAQ8CkB,uFAGiBnC,kHACtBA,kHASR3B","names":["clouds.shaders/u32-max","Math/floor","clouds.config/u32-max","clouds.shaders/u32-max-u","clouds.shaders/header","cljs.core.partial","sprog.iglu.core/iglu->glsl","clouds.shaders/worley-chunk","clojure.walk/prewalk-replace","clouds.shaders/render-frag","G__37249","cljs.core/Keyword","sprog.iglu.chunks.misc/pos-chunk","sprog.iglu.chunks.misc/bilinear-usampler-chunk","clouds.config/debug?","clouds.config/max-brightness","clouds.shaders/grid-of-spheres","clouds.config/default-record","clouds.shaders/loop-intersection","cljs.core.repeatedly","clouds.config/diffuse-material","cljs.core/cons","cljs.core.map","i","pos","position","cljs.core/even?","cljs.core.rand","clouds.config/motion-factor","clouds.config/create-diffuse-material","clouds.config/glass-material","cljs.core.range","clouds.config/rand-sphere-count","clouds.config/sphere-positions","clouds.shaders/trace-frag","sprog.iglu.chunks.misc/gradient-chunk","sprog.iglu.chunks.raytracing/sphere-intersection-chunk","sprog.iglu.chunks.raytracing/plane-intersection-chunk","sprog.iglu.chunks.raytracing/box-intersection-chunk","sprog.iglu.chunks.raytracing/raymarch-chunk","sprog.iglu.chunks.sdf/sphere-sdf-chunk","sprog.iglu.chunks.sdf/box-frame-sdf-chunk","sprog.iglu.chunks.sdf/box-sdf-chunk","sprog.iglu.chunks.transformations/axis-rotation-chunk","sprog.iglu.chunks.noise/simplex-3d-chunk","sprog.iglu.chunks.color/hsv-to-rgb-chunk","sprog.iglu.chunks.noise/pcg-hash-chunk","cljs.core.merge","clouds.config/materials-map","clouds.config/fudge-factor","Math/PI","clouds.config/skybox?","clouds.config/gold-light?","clouds.config/ambient-light-factor","clouds.config/sky-gold","clouds.config/light-pos","clouds.config/sun-factor","clouds.config/cam-pos","clouds.config/bounce-loop-limit","clouds.config/max-steps","clouds.shaders/worley-frag","sprog.iglu.chunks.noise/fbm-chunk","clouds.config/cloud-freq"],"sourcesContent":["(ns clouds.shaders\n  (:require [sprog.util :as u]\n            [clouds.config :as c]\n            [clojure.walk :refer [postwalk-replace]]\n            [sprog.iglu.core :refer [iglu->glsl\n                                     combine-chunks]]\n            [sprog.iglu.chunks.noise :refer [\n                                \n                                             simplex-3d-chunk\n                                             pcg-hash-chunk\n                                             fbm-chunk]]\n            [sprog.iglu.chunks.raytracing :refer [sphere-intersection-chunk\n                                                  plane-intersection-chunk\n                                                  box-intersection-chunk\n                                                  raymarch-chunk]]\n            [sprog.iglu.chunks.sdf :refer [sphere-sdf-chunk\n                                           box-frame-sdf-chunk\n                                           box-sdf-chunk]]\n            [sprog.iglu.chunks.transformations :refer [x-rotation-matrix-chunk\n                                                       y-rotation-matrix-chunk\n                                                       axis-rotation-chunk]]\n            [sprog.iglu.chunks.color :refer [hsv-to-rgb-chunk]]\n            [sprog.iglu.chunks.misc :refer [bilinear-usampler-chunk\n                                            pos-chunk\n                                            gradient-chunk]]\n            #_[fxrng.rng :refer [fxrand\n                               fxrand-int]]))\n\n(def u32-max (Math/floor c/u32-max))\n(def u32-max-u (str u32-max \"u\"))\n\n(def header \n  (partial iglu->glsl\n           '{:version \"300 es\"\n             :precision {float highp\n                         int highp\n                         usampler2D highp\n                         sampler2D highp}}))\n\n#_(def worley-offsets\n  (doall\n   (for [x (range -1 2)\n         y (range -1 2)\n         z (range -1 2)]\n     (vector x y z))))\n\n#_(def worley-unroll-expression\n  (u/unquotable\n   (cons 'do\n         (map (fn [offset]\n                (let [coord (cons 'vec3 offset)]\n                  (cons 'do\n                        (list '(= h (rand-pcg (+ id ~coord)))\n                              '(+= h ~coord)\n                              '(= d (- p h))\n                              '(= min-dist (min min-dist (dot d d)))))))\n              worley-offsets))))\n\n(def worley-chunk\n  (u/unquotable\n   '{:functions\n     {worley-noise\n      {([vec3] float)\n       ([pos]\n        (=vec3 id (floor pos))\n        (=vec3 p (fract pos))\n\n        (=float min-dist 10000)\n\n        (=vec3 h (vec3 0))\n        (=vec3 d (vec3 0))\n        #_~worley-unroll-expression\n\n        (\"for (float x = min(-1.0,(frame - 1.0)); x <= 1.0; ++x)\"\n         (\"for (float y = min(-1.0,(frame - 1.0)); y <= 1.0; ++y)\"\n          (\"for (float z = min(-1.0,frame - 1.0); z <= 1.0; ++z)\"\n           (=vec3 offset (vec3 x y z))\n           (=vec3 h (rand-pcg (+ id offset)))\n           (+= h offset)\n           (=vec3 d (- p h))\n           (= min-dist (min min-dist (dot d d))))))\n\n        min-dist)}}}))\n\n(def render-frag\n (u/unquotable\n   (header\n    pos-chunk\n    bilinear-usampler-chunk\n    '{:outputs {fragColor vec4}\n      :uniforms {size vec2\n                 final usampler2D\n                 skybox usampler2D}\n      :functions {aces-tonemap\n                  {([vec3] vec3)\n                   ([rgb]\n                    (clamp (/ (* rgb (+ 0.03 (* 2.51 rgb)))\n                              (+ 0.14 (* rgb (+ 0.59 (* 2.43 rgb)))))\n                           0\n                           1))}\n                  gamma-correction\n                  {([vec3] vec3)\n                   ([rgb]\n                    (pow rgb (vec3 (/ 1 2.2))))}\n                  pixel-color\n                  {([vec2] vec3)\n                   ([coords]\n                    ~(case c/debug?\n                       :skybox '(-> skybox\n                                    (textureBilinear coords)\n                                    .rgb\n                                    vec3\n                                    (/ ~u32-max)\n                                    aces-tonemap\n                                    gamma-correction)\n                       '(-> final\n                            (textureBilinear coords)\n                            .rgb\n                            vec3\n                            (/ ~u32-max)\n                            (* ~c/max-brightness)\n                            aces-tonemap\n                            gamma-correction)))}}\n      :main ((= fragColor (vec4 (pixel-color (/ gl_FragCoord.xy\n                                                size))\n                                1)))})))\n\n#_(def raymarch-test-chunk \n  (u/unquotable\n   '{:functions\n     {sdf\n      {([vec3] float)\n       ([pos]\n        (=float sfbm 1024)\n        (=float base-period 3)\n        (=vec3 base-pos (- (mod (+ pos\n                                   (* 0.5\n                                      base-period))\n                                base-period)\n                           (* 0.5 base-period)))\n        \n        (~(str \"for (int i = 0; i <\" c/sphere-octaves \"; ++i)\")\n         (=vec3 rot-pos (* pos\n                           (axisRotationMatrix (normalize \"sphere_axes[i]\")\n                                               \"sphere_angles[i]\")))\n         (=float scale (pow ~c/sphere-fbm-falloff\n                            (float i)))\n         (=float period (* 0.5\n                           scale))\n         (=vec3 q (- (mod (+ rot-pos\n                             (* 0.5\n                                period))\n                          period)\n                     (* 0.5 period)))\n\n         (=float spheres (sdSphere q (vec3 0)\n                                   (* ~c/sphere-layer-scale-factor\n                                      scale)))\n         (= sfbm (min sfbm\n                      spheres)))\n\n        (=float base (sdBox pos \n                            (vec3 0) \n                            (vec3 ~c/menger-size)))\n\n        (max (- 0 sfbm)\n             base))}\n      hit-world\n      {([Ray] Record)\n       ([ray]\n        (=Record record (Record false\n                                1024\n                                (vec3 0)\n                                (vec3 0)\n                                ~c/diffuse-material))\n        (=float distance 1024)\n        (=BoxIntersection bound (findBoxIntersection ray\n                                                      (vec3 0)\n                                                      (vec3 ~(+ c/menger-size 0.01))))\n\n        (\"if\" bound.hit\n         (=Ray bound-ray (Ray (ray-at ray bound.frontDist) ray.dir))\n         (= distance (raymarch sdf\n                               bound-ray\n                               (- bound.backDist\n                                  bound.frontDist)\n                               {:max-steps 40\n                                :step-size 1}))\n         (\"if\" (> distance 0)\n               (= record.hit true)\n               (= record.distance (+ distance\n                                     ~c/fudge-factor))\n               (= record.point (ray-at bound-ray record.distance))\n               (= record.normal (normalize\n                                 (findGradient 3\n                                               sdf\n                                               0.001\n                                               record.point)))\n               (= record.normal (if (> (dot ray.dir record.normal) 0)\n                                  record.normal\n                                  \"-record.normal\"))\n               (= record.material\n                  (Material :lambertian\n                            (hsv2rgb (vec3 0.125 0.34 0.36))\n                            (* 0.9 (- 1 (* -1 (dot ray.dir record.normal))))\n                            1))))\n        #_(=Sphere corner-sphere (Sphere (vec3 0 0.5 -0.5)\n                                       0.05\n                                       ~c/metallic-material))\n        #_(= distance (.x (findSphereIntersections ray\n                                                 corner-sphere.pos\n                                                 corner-sphere.radius)))\n\n        #_(\"if\" (&& (> distance 0)\n                  (< distance record.distance))\n              (= record.hit true)\n              (= record.distance (+ distance\n                                    ~c/fudge-factor))\n              (= record.point (ray-at ray record.distance))\n              (= record.normal (normalize (- record.point\n                                             corner-sphere.pos)))\n              (= record.material corner-sphere.material))\n\n        #_(=Plane plane (Plane (vec3 0 -5 0)\n                               (normalize (vec3 0\n                                                100\n                                                -2))\n                               ~c/ground-material))\n        #_(= distance (findPlaneIntersection ray\n                                             (Ray plane.pos\n                                                  plane.normal)))\n        #_(\"if\" (&& (> distance 0)\n                    (< distance record.distance))\n                (= record.hit true)\n                (= record.distance (+ distance\n                                      ~c/fudge-factor))\n                (= record.point (ray-at ray record.distance))\n                (= record.normal plane.normal)\n                (= record.material plane.material))\n\n        record)}}}))\n\n(def grid-of-spheres \n  (u/unquotable \n   '{:functions \n     {hit-world \n      {([Ray] Record)\n       ([ray]\n        (=Record (Record ~c/default-record)))}}}))\n\n(def loop-intersection \n  (u/unquotable \n   '{:functions \n    {hit-world \n     {([Ray] Record)\n      ([ray]\n       (=Record record (Record false\n                               1024\n                               (vec3 0)\n                               (vec3 0)\n                               ~c/diffuse-material))\n       (=Sphere sphere (Sphere (vec3 0)\n                               0\n                               ~c/diffuse-material))\n       (=float sphere-distance ~u32-max)\n\n       ~(cons 'do\n              (map\n               (fn [i pos]\n                 (let [position (cons 'vec2 pos)]\n                   '(do (= sphere\n                           (Sphere\n                            ~(if (and (even? i)\n                                      (> (rand) 0.5))\n                               '(vec3 (+ ~position\n                                         (* ~position\n                                            (* ~c/motion-factor\n                                               (vec2 (rand-pcg (+ rand-offset.xy\n                                                                  (* ray.dir.xy\n                                                                     10)))\n                                                     (rand-pcg (+ rand-offset.yz\n                                                                  (* ray.dir.xz\n                                                                     10))))))) 0)\n                               '(vec3 ~position 0))\n                            0.1\n                            ~(if (even? i)\n                               (c/create-diffuse-material (u/gen 3 (rand 2)))\n\n                               c/glass-material)))\n\n                        (= sphere-distance (.x\n                                            (findSphereIntersections ray\n                                                                     sphere.pos\n                                                                     sphere.radius)))\n\n                        (\"if\" (&& (> sphere-distance 0)\n                                  (< sphere-distance record.distance))\n                              (= record.hit true)\n                              (= record.distance sphere-distance)\n                              (= record.point (ray-at ray (fudge record.distance)))\n                              (= record.normal (normalize (- record.point\n                                                             sphere.pos)))\n\n                              (= record.material sphere.material)))))\n               (range c/rand-sphere-count)\n               c/sphere-positions))\n\n       (=Sphere middle-sphere (Sphere (vec3 0\n                                            0\n                                            0)\n                                      0.5\n                                      ~c/glass-material))\n\n       (= sphere-distance (.x (findSphereIntersections ray\n                                                       middle-sphere.pos\n                                                       middle-sphere.radius)))\n       (\"if\" (&& (> sphere-distance 0)\n                 (< sphere-distance record.distance))\n             (= record.hit \"true\")\n             (= record.distance sphere-distance)\n             (= record.point (ray-at ray (fudge record.distance)))\n             (= record.normal (normalize (- record.point\n                                            middle-sphere.pos)))\n\n             (= record.material middle-sphere.material))\n\n       record)}}}))\n\n(def trace-frag\n  (u/unquotable\n   (header\n    pos-chunk\n    bilinear-usampler-chunk\n    gradient-chunk\n\n    sphere-intersection-chunk\n    plane-intersection-chunk\n    box-intersection-chunk\n\n    raymarch-chunk\n    sphere-sdf-chunk\n    box-frame-sdf-chunk\n    box-sdf-chunk\n\n    axis-rotation-chunk\n\n    loop-intersection\n\n    simplex-3d-chunk\n    hsv-to-rgb-chunk\n    pcg-hash-chunk\n    '{:constants ~(merge {}\n                         c/materials-map)\n      :defines {(fudge x) (+ x ~c/fudge-factor)}\n      :outputs {Color uvec4\n                Position uvec4\n                Direction uvec4\n                Accumulated uvec4\n                Attenuation uvec4\n                Meta uvec4}\n      :layout {Color 0\n               Position 1\n               Direction 2\n               Accumulated 3\n               Attenuation 4\n               Meta 5}\n      :uniforms {size vec2\n                 rand-offset vec3\n                 ray-pos-tex usampler2D\n                 ray-dir-tex usampler2D\n                 color-tex usampler2D\n                 accumulation-tex usampler2D\n                 attenuation-tex usampler2D\n                 ray-meta-tex usampler2D\n                 skybox usampler2D\n                 frame float}\n      :structs {Ray\n                [pos vec3\n                 dir vec3\n                 color vec3\n                 attenuation vec3]\n                Sphere\n                [pos vec3\n                 radius float\n                 material Material]\n                Plane\n                [pos vec3\n                 normal vec3\n                 material Material]\n                Material\n                [type int\n                 albedo vec3\n                 specular vec3\n                 emissive vec3\n                 roughness float\n                 ior float]\n                Record\n                [hit bool\n                 distance float\n                 point vec3\n                 normal vec3\n                 material Material]}\n      :functions\n      {hemisphere-uniform\n       {([vec3] vec4)\n        ([normal]\n         (=vec3 rand-vec (rand-pcg (+ rand-offset\n                                      (* normal\n                                         100))))\n         (=float cos-theta rand-vec.x)\n         (=float sin-theta (sqrt (- 1 (* cos-theta cos-theta))))\n\n         (=float phi (* 2\n                        ~Math/PI\n                        rand-vec.y))\n         ;\"spherical to cartesian\"\n         (=vec3 t (normalize (cross normal.yzx normal)))\n         (=vec3 b (cross normal t))\n         (vec4 (+ (* sin-theta\n                     (+ (* t\n                           (cos phi))\n                        (* b\n                           (sin phi))))\n                  (* normal\n                     cos-theta))\n               1))}\n\n       hemisphere-cosine\n       {([vec3] vec4)\n        ([normal]\n         (=vec3 rand-vec (rand-pcg (+ rand-offset\n                                      normal)))\n         (=float cos-theta rand-vec.x)\n         (=float sin-theta (sqrt (- 1 (* cos-theta cos-theta))))\n\n         (=float phi (* 2\n                        ~Math/PI\n                        rand-vec.y))\n         ;\"spherical to cartesian\"\n         (=vec3 t (normalize (cross normal.yzx normal)))\n         (=vec3 b (cross normal t))\n\n         (=vec3 l (+ (* sin-theta\n                        (+ (* t\n                              (cos phi))\n                           (* b\n                              (sin phi))))\n                     (* normal\n                        cos-theta)))\n         (=float pdf (* ~(/ Math/PI)\n                        cos-theta))\n         (vec4 l (/ ~(/ 0.5 Math/PI)\n                    (+ pdf 1e-6))))}\n\n       hemisphere-ggx\n       {([vec3 vec3 float] vec4)\n        ([normal v roughness]\n         (=float temp (* roughness roughness))\n         (=float alpha (* temp temp))\n\n         (=vec3 rand-vec (rand-pcg (+ rand-offset\n                                      normal)))\n\n         (=float epsilon (clamp rand-vec.x 0.001 1))\n         (=float cos-theta2 (/ (- 1 epsilon)\n                               (+ (* epsilon (- alpha 1))\n                                  1)))\n         (=float cos-theta (sqrt cos-theta2))\n         (=float sin-theta (sqrt (- 1 cos-theta2)))\n\n         (=float phi (* 2\n                        ~Math/PI\n                        rand-vec.y))\n\n         ;\"spherical to cartesian\"\n         (=vec3 t (normalize (cross normal.yzx normal)))\n         (=vec3 b (cross normal t))\n\n         (=vec3 micro-normal\n                (+ (* t\n                      (cos phi))\n                   (* b\n                      (sin phi)\n                      sin-theta)\n                   (* normal cos-theta)))\n         (=vec3 l (reflect \"-v\" micro-normal))\n\n         ;\"sample weight\"\n         (=float den (* (- alpha 1)\n                        (+ cos-theta2 1)))\n         (=float d (/ alpha\n                      (* ~Math/PI\n                         den\n                         den)))\n         (=float pdf (/ (* d cos-theta)\n                        (* 4\n                           (dot micro-normal\n                                v))))\n\n         (=float weight (if (< (dot l normal) 0)\n                          0\n                          (/ ~(/ 0.5 Math/PI)\n                             (+ pdf 1e-6))))\n\n         (vec4 l weight))}\n       ggx\n       {([vec3 vec3 vec3 float vec3] vec3)\n        ([normal dir reflected roughness specular]\n         (=float temp (* roughness roughness))\n         (=float alpha (* temp temp))\n\n         (=float dot-normal (clamp (dot normal reflected) 0 1))\n         (=float dot-dir (clamp (dot normal dir) 0 1))\n\n         (=vec3 h (normalize (+ dir reflected)))\n\n         (=float dot-normal-h (clamp (dot normal h) 0 1))\n         (=float dot-reflected-h (clamp (dot reflected h) 0 1))\n\n         ;GGX microfacet distribution function\n         (=float den (+ (* (- alpha 1)\n                           dot-normal-h\n                           dot-normal-h)\n                        1))\n         (=float density (/ alpha (* ~Math/PI\n                                     den\n                                     den)))\n\n         ;fresnel with schlick approximation\n         (=vec3 fresnel (+ specular\n                           (* (- 1 specular)\n                              (pow (- 1 dot-reflected-h) 5))))\n\n         ;Smith joint masking-shadowing fn \n         (=float k (* 0.5 alpha))\n         (=float g (/ (* (+ k\n                            (* dot-normal\n                               (- 1 k)))\n                         (+ k\n                            (* dot-dir\n                               (- 1 k))))))\n         (* density fresnel g))}\n       ray-at\n       {([Ray float] vec3)\n        ([ray distance]\n         (+ ray.pos (* ray.dir\n                       distance)))}\n\n       reflect-ray\n       {([Ray Record] Ray)\n        ([ray record]\n         (=vec3 attenuation ray.attenuation)\n         (=float cos-theta-i (dot ray.dir record.normal))\n         (=vec3 facing-normal (if (< cos-theta-i 0)\n                                record.normal\n                                (- record.normal)))\n         (=vec3 collected-color (+ ray.color\n                                   (* ray.attenuation\n                                      record.material.emissive)))\n\n         (=vec3 outgoing-dir (vec3 0))\n\n         (\"if\" (== record.material.type\n                   :lambertian)\n               (=vec4 dir-sample (hemisphere-cosine\n                                  facing-normal))\n               (= outgoing-dir dir-sample.xyz)\n               (*= attenuation dir-sample.w)\n               (*= attenuation (* record.material.albedo\n                                  (dot facing-normal\n                                       outgoing-dir))))\n         (\"else if\" (== record.material.type :blinn-phong)\n                    (=vec4 dir-sample (hemisphere-cosine\n                                       facing-normal))\n                    (= outgoing-dir dir-sample.xyz)\n                    (=vec3 h (normalize (+ \"ray.dir\"\n                                           outgoing-dir)))\n                    (*= attenuation dir-sample.w)\n                    (*= attenuation (+ (* record.material.albedo\n                                          (dot facing-normal\n                                               outgoing-dir))\n\n                                       (* record.material.specular\n                                          (pow (max (dot facing-normal\n                                                         h)\n                                                    0)\n                                               record.material.roughness)))))\n         (\"else if\" (== record.material.type\n                        :specular)\n                    (= outgoing-dir (reflect ray.dir facing-normal))\n                    (*= attenuation record.material.specular)\n\n                    #_(=vec3 reflected-dir (normalize\n                                            (reflect ray.dir\n                                                     record.normal)))\n                    #_(= outgoing-dir\n                         (normalize (+ reflected-dir\n                                       random-dir))))\n         (\"else if\" (== record.material.type\n                        :dielectric)\n                    (=float eta (if (< cos-theta-i 0)\n                                  (/ record.material.ior)\n                                  record.material.ior))\n                    (=vec3 refracted (refract ray.dir facing-normal eta))\n\n                    (\"if\" (all (equal refracted (vec3 0)))\n                          (= outgoing-dir (reflect ray.dir facing-normal)))\n                    (\"else\"\n                     ;fresnel with schlick approximation\n                     (=float temp (/ (- record.material.ior 1)\n                                     (+ 1 record.material.ior)))\n                     (=float pre-fres (* temp temp))\n                     (=float cos-theta (if (< cos-theta-i 0)\n                                         (- cos-theta-i)\n                                         (dot refracted record.normal)))\n                     (=float fresnel (+ pre-fres (* (- 1 pre-fres)\n                                                    (pow (- 1 cos-theta)\n                                                         5))))\n\n                     (\"if\" (< (.x (rand-pcg (+ rand-offset\n                                               ray.dir)))\n                              fresnel)\n                           (= outgoing-dir (reflect ray.dir facing-normal)))\n                     (\"else\"\n                      (*= attenuation record.material.albedo)\n                      (= outgoing-dir refracted)))\n\n\n\n                    #_(=vec3 reflected-dir (normalize\n                                            (reflect ray.dir\n                                                     record.normal)))\n                    #_(= outgoing-dir\n                         (if (> (rand-pcg (+ (* 100\n                                                gl_FragCoord.xy)\n                                             rand-offset.xy))\n                                0.75)\n                           reflected-dir\n                           (normalize\n                            (refract ray.dir\n                                     record.normal\n                                     record.material.ior)))))\n         (\"else if\" (== record.material.type :lommel)\n                    (*= attenuation record.material.albedo)\n                    (= outgoing-dir (-> facing-normal\n                                        hemisphere-uniform\n                                        .xyz)))\n         (\"else if\" (== record.material.type\n                        :ggx)\n                    (=vec4 dir-sample (vec4 1))\n                    (\"if\" (&& (> (length record.material.albedo)\n                                 0.04)\n                              (< (rand-pcg (+ rand-offset.xy\n                                              (* ray.dir.xy\n                                                 100)))\n                                 0.5))\n                          (= dir-sample (hemisphere-cosine facing-normal))\n                          (= outgoing-dir dir-sample.xyz)\n                          (*= attenuation dir-sample.w)\n                          (*= attenuation (* record.material.albedo\n                                             (dot facing-normal\n                                                  outgoing-dir))))\n                    (\"else\"\n                     (= dir-sample (hemisphere-ggx facing-normal\n                                                   (- ray.dir)\n                                                   record.material.roughness))\n                     (= outgoing-dir dir-sample.xyz)\n                     (*= attenuation dir-sample.w)\n                     (*= attenuation (* (dot facing-normal\n                                             outgoing-dir)\n                                        (ggx facing-normal\n                                             (- ray.dir)\n                                             outgoing-dir\n                                             record.material.roughness\n                                             record.material.specular)))))\n         (Ray record.point\n              outgoing-dir\n              (+ ray.color collected-color)\n              attenuation))}\n       exit-color\n       {([Ray] vec3)\n        ([ray]\n         (+ ~(if c/skybox?\n               '(-> skybox\n                    (textureBilinear (bi->uni ray.dir.xy))\n                    .rgb\n                    vec3\n                    (/ ~u32-max))\n               '0)\n            (* (smoothstep -1\n                           1\n                           (dot ray.dir\n                                (vec3 0)))\n               ~(if c/gold-light?\n                  '(* ~c/ambient-light-factor\n                      ~c/sky-gold)\n                  '(vec3 ~c/ambient-light-factor)))\n            (* (smoothstep 0.91\n                           1\n                           (dot ray.dir\n                                (normalize ~c/light-pos)))\n\n               ~c/sun-factor)))}}\n      :main ((=vec2 pos (getPos))\n             (=ivec2 frag-pos (ivec2 gl_FragCoord.xy))\n\n             (=uvec4 meta-color\n                     (texelFetch ray-meta-tex frag-pos \"0\"))\n             (=int step (int meta-color.x))\n             (=int accumulation-index (int meta-color.y))\n\n             (=bool ray-finished false)\n\n             (=vec3 old-accumulated (-> accumulation-tex\n                                        (texelFetch frag-pos \"0\")\n                                        .xyz\n                                        vec3\n                                        (/ ~u32-max)))\n            \n             (=Ray ray\n                   (Ray (if (== step \"0\")\n                          ~c/cam-pos\n                          (-> ray-pos-tex\n                              (texelFetch frag-pos \"0\")\n                              .xyz\n                              vec3\n                              (/ ~u32-max)\n                              uni->bi))\n                        (if (== step \"0\")\n                          (-> pos\n                              (* 2)\n                              (- 1)\n                              (vec3 1)\n                              normalize)\n                          (-> ray-dir-tex\n                              (texelFetch frag-pos \"0\")\n                              .xyz\n                              vec3\n                              (/ ~u32-max)\n                              uni->bi))\n                        (if (== step \"0\")\n                          (vec3 0)\n                          (-> color-tex\n                              (texelFetch frag-pos \"0\")\n                              .xyz\n                              vec3\n                              (/ ~u32-max)))\n                        (if (== step \"0\")\n                          (vec3 1)\n                          (-> attenuation-tex\n                              (texelFetch frag-pos \"0\")\n                              .xyz\n                              vec3\n                              (/ ~u32-max)))))\n             (~(str \"for(int s=0;s<\" c/bounce-loop-limit \";s++)\")\n              (=Record record (hit-world ray))\n\n              (\"if\" record.hit\n\n                    (= ray (reflect-ray ray record))\n                    (+= step \"1\")\n                    (\"if\" (> step ~(str c/max-steps))\n                          (= ray-finished true)\n                          (= ray.color (vec3 0))\n                          \"break\"))\n\n              (\"else\"\n               (+= ray.color\n                   (* ray.attenuation (exit-color ray)))\n               (= ray-finished true)\n               \"break\"))\n\n             (= Color (uvec4 (uvec3 (* ray.color\n                                       ~u32-max))\n                             ~u32-max-u))\n             (= Position (uvec4 (uvec3 (* (-> ray.pos\n                                              bi->uni)\n                                          ~u32-max))\n                                ~u32-max-u))\n             (= Direction (uvec4 (uvec3 (* (-> ray.dir\n                                               bi->uni)\n                                           ~u32-max))\n                                 ~u32-max-u))\n             (= Accumulated (uvec4\n                             (uvec3\n                              (* (if ray-finished\n                                   (clamp\n                                    (mix old-accumulated\n                                         (/ ray.color\n                                            ~c/max-brightness)\n                                         (/ 1 (+ 1\n                                                 (float accumulation-index))))\n                                    0 1)\n                                   old-accumulated)\n                                 ~u32-max))\n                             ~u32-max-u))\n             (= Attenuation (uvec4 (* ray.attenuation\n                                      ~u32-max)\n                                   ~u32-max-u))\n             (= Meta (uvec4 (if ray-finished\n                              \"0\"\n                              step)\n                            (if ray-finished\n                              (+ accumulation-index \"1\")\n                              accumulation-index)\n                            0\n                            0)))})))\n\n(def worley-frag\n  (u/unquotable\n   (header\n    worley-chunk\n    fbm-chunk\n    pcg-hash-chunk\n    simplex-3d-chunk\n    '{:outputs {fragColor uvec4}\n      :uniforms {size vec2\n                 frame float}\n      :main ((=vec2 pos (/ gl_FragCoord.xy size))\n             (=float worley-fbm (fbm worley-noise\n                                     3\n                                     (vec3 (+ (* pos\n                                                 ~c/cloud-freq)\n                                              (* 0.025\n                                                 (snoise3D (vec3 (* pos 20)\n                                                                 ~(rand 1000)))))\n                                           ~(rand 1000))\n                                     \"5\"\n                                     0.75))\n             (= fragColor (uvec4 (* (mix (vec3 0.129 0.3078 0.9213)\n                                         (vec3 1)\n                                         (-> (- 1 worley-fbm)\n                                             (- 0.5)\n                                             (/ 0.5)\n                                             (max 0)))\n                                    ~u32-max)\n                                 (uvec3 \"0u\"))))})))"]}