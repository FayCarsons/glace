{"version":3,"sources":["clouds/shaders.cljs"],"mappings":";AAwCA,AAAKA,yBAAQC;AACb,2BAAA,3BAAKC;AAEL,AAAKC,wBACH,8EAAA,AAAA,9EAACC,gDAAQC;AAOX,AAAKC,6BACJ,AAAA,sGAAA,iDAAA,mDAAA,mDAAA,KAAA,OAAA,AAAAC,6BAAA,2CAAA,0FAAA,6FAAA,sGAAA,AAAA,9mBACGJ,sBACAK,iCACAC,+CACCC,oGAAsBC,oMAyBCC,0FAI2BC,8FAKAA;AASvD,AAAKC,4BACH,AAAA,g3BAAA,AAAAP,6BAAA,wCAAA,8DAAA,6DAAA,8DAAA,6DAAA,8DAAA,6DAAA,2DAAA,6DAAA,4DAAA,6DAAA,6DAAA,4DAAA,6DAAA,4DAAA,8DAAA,8DAAA,4DAAA,4DAAA,6DAAA,8DAAA,6DAAA,8DAAA,8DAAA,6DAAA,6DAAA,6DAAA,8DAAA,6DAAA,6DAAA,6DAAA,6DAAA,6DAAA,4DAAA,6DAAA,2DAAA,4DAAA,8DAAA,6DAAA,8DAAA,4DAAA,4DAAA,6DAAA,yIAAA,mCAAA,AAAAA,6BAAA,2CAAA,gGAAA,4FAAA,AAAA,6LAAA,AAAAA,6BAAA,2CAAA,wGAAA,AAAA,yLAAA,CAAA,oNAAA,CAAA,6DAAA,CAAA,8CAAA,qEAAA,+BAAA,AAAAA,6BAAA,2CAAA,6FAAA,AAAA,2mBAAA,AAAA,aAAA,eAAA,AAAA,mQAAA,CAAA,8FAAA,6OAAA,AAAA,5qMACEJ,sBACAK,iCACAC,+CACAM,sCAEAC,uDACAC,iCACAC,oDAEAC,6BACAC,8BACAC,uCACAC,0CACAC,oCACAC,0CACAC,sDACAC,mCACAC,mCACAC,+CACAC,yCACAC,iDAIAC,yCACAC,yCACAC,q2HACcC,q1CACcC,zBAuDaC,5TAGlBC,zoEAQaD,snFAGPC,tqFAECA,ilEAeTC,lkEAwBAA,iqCAaGA,9DAEAA,5JAqBHA,uqDAoBCA,huDAUWA,iwDAwBCA,taA4FaF,oOAmBGA,7rCA8BrCG,mKAKOvC,v3CAMJwC,sKACGC,gGACAC,iWACGD,snDACbE,l4CAiB+B3C,qFAGjB4C,qkDACAC,3PAIWA,7wCAKuBC,ytCAUb9C,xLAKpB+C,yEAAWC,nyCAKLhD,mRASAA,jHAOAA,w4CACGiD,rqCAOGC,o8BAYAlD,jrEACVE,6jCAGaF,vJACVE,8LAGWF,rRACVE,wHAOWU,2kDAKXZ,1UACJE,uYAESF,+BACHE;AAUpC,AAAKiD,6BACH,AAAA,mKAAA,AAAA5C,6BAAA,2CAAA,uFAAA,6DAAA,6CAAA,QAAA,4DAAA,6CAAA,QAAA,4FAAA,AAAA,joBACEJ,sBACAiD,2BACAC,kCACApB,uCACAF,+KAQ8CuB,sFAGiBC,iHACtBA,kHASRvD","names":["clouds.shaders/u32-max","clouds.config/u32-max","clouds.shaders/u32-max-u","clouds.shaders/header","cljs.core.partial","sprog.iglu.core/iglu->glsl","clouds.shaders/render-frag","clojure.walk/prewalk-replace","sprog.iglu.chunks.misc/pos-chunk","sprog.iglu.chunks.misc/bilinear-usampler-chunk","sprog.iglu.chunks.postprocessing/get-bloom-chunk","sprog.iglu.chunks.postprocessing/star-neighborhood","clouds.config/max-brightness","clouds.config/aberration-offset","clouds.shaders/trace-frag","sprog.iglu.chunks.misc/gradient-chunk","sprog.iglu.chunks.raytracing/sphere-intersection-chunk","clouds.chunks/plane-intersection","sprog.iglu.chunks.raytracing/box-intersection-chunk","clouds.chunks/raymarch-chunk","clouds.intersections/dof-test","sprog.iglu.chunks.sdf/sphere-sdf-chunk","sprog.iglu.chunks.sdf/box-frame-sdf-chunk","sprog.iglu.chunks.sdf/box-sdf-chunk","sprog.iglu.chunks.noise/rand-normal-chunk","sprog.iglu.chunks.transformations/axis-rotation-chunk","sprog.iglu.chunks.sdf/twistX-chunk","sprog.iglu.chunks.sdf/twistY-chunk","sprog.iglu.chunks.sdf/smooth-subtraction-chunk","sprog.iglu.chunks.sdf/smooth-union-chunk","sprog.iglu.chunks.sdf/smooth-intersectioon-chunk","sprog.iglu.chunks.noise/simplex-3d-chunk","sprog.iglu.chunks.color/hsv-to-rgb-chunk","sprog.iglu.chunks.noise/pcg-hash-chunk","clouds.materials/materials-map","clouds.config/fudge-factor","clouds.config/rand-scale","sprog.util/TAU","Math/PI","clouds.config/skybox?","clouds.config/gold-light?","clouds.config/ambient-light-factor","clouds.config/sky-gold","clouds.config/sun-expression","clouds.config/depth-of-field-strength","clouds.config/depth-of-field-distance","clouds.config/field-of-view","cljs.core/cons","clouds.config/cam-pos","clouds.config/bounce-loop-limit","clouds.config/max-steps","clouds.shaders/worley-frag","clouds.chunks/worley-chunk","sprog.iglu.chunks.noise/fbm-chunk","clouds.config/cloud-freq","cljs.core.rand"],"sourcesContent":["(ns clouds.shaders\n  (:require [sprog.util :as u]\n            [clouds.config :as c]\n            [clouds.chunks :refer [worley-chunk\n                                   raymarch-chunk\n                                   plane-intersection]]\n            [clouds.intersections :as i]\n            [clouds.materials :as mat]\n            [clojure.walk :refer [postwalk-replace]]\n            [sprog.iglu.core :refer [iglu->glsl\n                                     combine-chunks]]\n            [sprog.iglu.chunks.noise :refer [rand-normal-chunk\n                                             simplex-3d-chunk\n                                             pcg-hash-chunk\n                                             fbm-chunk]]\n            [sprog.iglu.chunks.raytracing :refer [sphere-intersection-chunk\n                                                  plane-intersection-chunk\n                                                  box-intersection-chunk]]\n            [sprog.iglu.chunks.sdf :refer [sphere-sdf-chunk\n                                           box-frame-sdf-chunk\n                                           box-sdf-chunk\n                                           twistX-chunk\n                                           twistY-chunk\n                                           smooth-union-chunk\n                                           smooth-intersectioon-chunk\n                                           smooth-subtraction-chunk]]\n            [sprog.iglu.chunks.transformations :refer [x-rotation-matrix-chunk\n                                                       y-rotation-matrix-chunk\n                                                       axis-rotation-chunk]]\n            [sprog.iglu.chunks.color :refer [hsv-to-rgb-chunk]]\n            [sprog.iglu.chunks.postprocessing :refer [square-neighborhood\n                                                      star-neighborhood\n                                                      plus-neighborhood\n                                                      get-bloom-chunk]]\n            [sprog.iglu.chunks.misc :refer [bilinear-usampler-chunk\n                                            pos-chunk\n                                            gradient-chunk]]\n            #_[fxrng.rng :refer [fxrand\n                               fxrand-int]]))\n\n(def u32-max c/u32-max)\n(def u32-max-u \"0xFFFFFFFFu\")\n\n(def header \n  (partial iglu->glsl\n           '{:version \"300 es\"\n             :precision {float highp\n                         int highp\n                         usampler2D highp\n                         sampler2D highp}}))\n\n(def render-frag\n (u/unquotable\n   (header\n    pos-chunk\n    bilinear-usampler-chunk\n    (get-bloom-chunk :u32 (star-neighborhood 2) 0.333)\n    '{:outputs {fragColor vec4}\n      :uniforms {size vec2\n                 final usampler2D\n                 skybox usampler2D\n                 bilateral? bool}\n      :functions {aces-tonemap\n                  {([vec3] vec3)\n                   ([rgb]\n                    (clamp (/ (* rgb (+ 0.03 (* 2.51 rgb)))\n                              (+ 0.14 (* rgb (+ 0.59 (* 2.43 rgb)))))\n                           0\n                           1))}\n                  gamma-correction\n                  {([vec3] vec3)\n                   ([rgb]\n                    (pow rgb (vec3 (/ 1 2.2))))}\n                  pixel-color\n                  {([vec2] vec3)\n                   ([coords]\n                    (-> final\n                        (bloom coords 0 0.1)\n                        .rgb\n                        vec3\n                        \n                        (* ~c/max-brightness)\n                        aces-tonemap))}}\n      :main ((=vec2 pos (/ gl_FragCoord.xy size))\n             (do (=float r (.r (pixel-color (clamp (- pos\n                                                      ~c/aberration-offset)\n                                                   (vec2 0)\n                                                   (vec2 1)))))\n                 (=float g (.g (pixel-color pos)))\n                 (=float b (.b (pixel-color (clamp (+ pos\n                                                      ~c/aberration-offset)\n                                                   (vec2 0)\n                                                   (vec2 1))))))\n             (=vec3 color (gamma-correction (vec3 r g b)))\n             (= fragColor (vec4 (gamma-correction (aces-tonemap color))\n                                1)))})))\n\n\n\n(def trace-frag\n  (u/unquotable\n   (header\n    pos-chunk\n    bilinear-usampler-chunk\n    gradient-chunk\n\n    sphere-intersection-chunk\n    plane-intersection\n    box-intersection-chunk\n\n    raymarch-chunk\n    i/dof-test\n    sphere-sdf-chunk\n    box-frame-sdf-chunk\n    box-sdf-chunk\n    rand-normal-chunk\n    axis-rotation-chunk\n    twistX-chunk\n    twistY-chunk\n    smooth-subtraction-chunk\n    smooth-union-chunk\n    smooth-intersectioon-chunk\n\n\n\n    simplex-3d-chunk\n    hsv-to-rgb-chunk\n    pcg-hash-chunk\n    '{:constants ~mat/materials-map\n      :defines {(fudge x) (* x ~c/fudge-factor)}\n      :outputs {Color uvec4\n                Position uvec4\n                Direction uvec4\n                Accumulated uvec4\n                Attenuation uvec4\n                Meta uvec4}\n      :layout {Color 0\n               Position 1\n               Direction 2\n               Accumulated 3\n               Attenuation 4\n               Meta 5}\n      :uniforms {size vec2\n                 camera mat3\n                 rand-offset vec3\n                 ray-pos-tex usampler2D\n                 ray-dir-tex usampler2D\n                 color-tex usampler2D\n                 accumulation-tex usampler2D\n                 attenuation-tex usampler2D\n                 ray-meta-tex usampler2D\n                 skybox usampler2D\n                 frame float}\n      :structs {Ray\n                [pos vec3\n                 dir vec3\n                 color vec3\n                 attenuation vec3]\n                Sphere\n                [pos vec3\n                 radius float\n                 material Material]\n                Plane\n                [normal vec3\n                 depth float\n                 material Material]\n                Material\n                [type int\n                 albedo vec3\n                 specular vec3\n                 emissive vec3\n                 roughness float\n                 ior float]\n                Record\n                [hit bool\n                 distance float\n                 point vec3\n                 normal vec3\n                 material Material]}\n      :functions\n      {random-point-in-circle\n       {([] vec2)\n        ([]\n         (=vec2 random (.xy (rand-pcg (+ (* gl_FragCoord.xyz\n                                            ~c/rand-scale)\n                                         rand-offset))))\n         (=float angle (* (.x random)\n                          ~u/TAU))\n         (=float radius (sqrt random.y))\n         (* radius (vec2 (cos angle)\n                         (sin angle))))}\n       random-point-in-star\n       {([float] vec2)\n        ([sides]\n         (=vec3 random (rand-pcg (+ (* gl_FragCoord.xyz\n                                       ~c/rand-scale)\n                                    rand-offset)))\n         (=float n (/ (floor (* random.x sides)) sides))\n         (=float angle-one (* n ~u/TAU))\n         (=float angle-two (+ angle-one\n                              (/ ~u/TAU sides)))\n         (=vec2 s1 (vec2 (cos angle-one) (sin angle-one)))\n         (=vec2 s2 (vec2 (cos angle-two) (sin angle-two)))\n         (+ (* random.y s1)\n            (* random.z s2)))}\n       hemisphere-uniform\n       {([vec3] vec4)\n        ([normal]\n         (=vec3 rand-vec (rand-pcg (+ rand-offset\n                                      normal\n                                      gl_FragCoord.xyz)))\n         (=float cos-theta rand-vec.x)\n         (=float sin-theta (sqrt (- 1 (* cos-theta cos-theta))))\n\n         (=float phi (* 2\n                        ~Math/PI\n                        rand-vec.y))\n         ;\"spherical to cartesian\"\n         (=vec3 t (normalize (cross normal.yzx normal)))\n         (=vec3 b (cross normal t))\n         (vec4 (+ (* sin-theta\n                     (+ (* t\n                           (cos phi))\n                        (* b\n                           (sin phi))))\n                  (* normal\n                     cos-theta))\n               1))}\n\n       hemisphere-cosine\n       {([vec3] vec4)\n        ([normal]\n         (=vec3 rand-vec (rand-pcg (+ rand-offset\n                                      normal\n                                      gl_FragCoord.xyz)))\n         (=float cos-theta rand-vec.x)\n         (=float sin-theta (sqrt (- 1 (* cos-theta cos-theta))))\n\n         (=float phi (* 2\n                        ~Math/PI\n                        rand-vec.y))\n         ;\"spherical to cartesian\"\n         (=vec3 t (normalize (cross normal.yzx normal)))\n         (=vec3 b (cross normal t))\n\n         (=vec3 l (+ (* sin-theta\n                        (+ (* t\n                              (cos phi))\n                           (* b\n                              (sin phi))))\n                     (* normal\n                        cos-theta)))\n         (=float pdf (* ~(/ Math/PI)\n                        cos-theta))\n         (vec4 l (/ ~(/ 0.5 Math/PI)\n                    (+ pdf 1e-6))))}\n\n       hemisphere-ggx\n       {([vec3 vec3 float] vec4)\n        ([normal v roughness]\n         (=float temp (* roughness roughness))\n         (=float alpha (* temp temp))\n\n         (=vec3 rand-vec (rand-pcg (+ rand-offset\n                                      normal\n                                      gl_FragCoord.xyz)))\n\n         (=float epsilon (clamp rand-vec.x 0.001 1))\n         (=float cos-theta2 (/ (- 1 epsilon)\n                               (+ (* epsilon (- alpha 1))\n                                  1)))\n         (=float cos-theta (sqrt cos-theta2))\n         (=float sin-theta (sqrt (- 1 cos-theta2)))\n\n         (=float phi (* 2\n                        ~Math/PI\n                        rand-vec.y))\n\n         ;\"spherical to cartesian\"\n         (=vec3 t (normalize (cross normal.yzx normal)))\n         (=vec3 b (cross normal t))\n\n         (=vec3 micro-normal\n                (+ (* t\n                      (cos phi))\n                   (* b\n                      (sin phi)\n                      sin-theta)\n                   (* normal cos-theta)))\n         (=vec3 l (reflect \"-v\" micro-normal))\n\n         ;\"sample weight\"\n         (=float den (* (- alpha 1)\n                        (+ cos-theta2 1)))\n         (=float d (/ alpha\n                      (* ~Math/PI\n                         den\n                         den)))\n         (=float pdf (/ (* d cos-theta)\n                        (* 4\n                           (dot micro-normal\n                                v))))\n\n         (=float weight (if (< (dot l normal) 0)\n                          0\n                          (/ ~(/ 0.5 Math/PI)\n                             (+ pdf 1e-6))))\n\n         (vec4 l weight))}\n\n       ggx\n       {([vec3 vec3 vec3 float vec3] vec3)\n        ([normal dir reflected roughness specular]\n         (=float temp (* roughness roughness))\n         (=float alpha (* temp temp))\n\n         (=float dot-normal (clamp (dot normal reflected) 0 1))\n         (=float dot-dir (clamp (dot normal dir) 0 1))\n\n         (=vec3 h (normalize (+ dir reflected)))\n\n         (=float dot-normal-h (clamp (dot normal h) 0 1))\n         (=float dot-reflected-h (clamp (dot reflected h) 0 1))\n\n         ;GGX microfacet distribution function\n         (=float den (+ (* (- alpha 1)\n                           dot-normal-h\n                           dot-normal-h)\n                        1))\n         (=float density (/ alpha (* ~Math/PI\n                                     den\n                                     den)))\n\n         ;fresnel with schlick approximation\n         (=vec3 fresnel (+ specular\n                           (* (- 1 specular)\n                              (pow (- 1 dot-reflected-h) 5))))\n\n         ;Smith joint masking-shadowing fn \n         (=float k (* 0.5 alpha))\n         (=float g (/ (* (+ k\n                            (* dot-normal\n                               (- 1 k)))\n                         (+ k\n                            (* dot-dir\n                               (- 1 k))))))\n         (* density fresnel g))}\n\n       ray-at\n       {([Ray float] vec3)\n        ([ray distance]\n         (+ ray.pos (* ray.dir\n                       distance)))}\n\n       reflect-ray\n       {([Ray Record] Ray)\n        ([ray record]\n         (=vec3 attenuation ray.attenuation)\n         (=float cos-theta-i (dot ray.dir record.normal))\n         (=vec3 facing-normal (if (< cos-theta-i 0)\n                                record.normal\n                                (- record.normal)))\n         (=vec3 collected-color (+ ray.color\n                                   (* ray.attenuation\n                                      record.material.emissive)))\n\n         (=vec3 outgoing-dir (vec3 0))\n\n         (\"if\" (== record.material.type\n                   :lambertian)\n               (=vec4 dir-sample (hemisphere-cosine\n                                  facing-normal))\n               (= outgoing-dir dir-sample.xyz)\n               (*= attenuation dir-sample.w)\n               (*= attenuation (* record.material.albedo\n                                  (dot facing-normal\n                                       outgoing-dir))))\n         (\"else if\" (== record.material.type :blinn-phong)\n                    (=vec4 dir-sample (hemisphere-cosine\n                                       facing-normal))\n                    (= outgoing-dir dir-sample.xyz)\n                    (=vec3 h (normalize (+ (- ray.dir)\n                                           outgoing-dir)))\n                    (*= attenuation dir-sample.w)\n                    (*= attenuation (+ (* record.material.albedo\n                                          (dot facing-normal\n                                               outgoing-dir))\n\n                                       (* record.material.specular\n                                          (pow (max (dot facing-normal\n                                                         h)\n                                                    0)\n                                               record.material.roughness)))))\n         (\"else if\" (== record.material.type\n                        :specular)\n                    (= outgoing-dir (reflect ray.dir facing-normal))\n                    (*= attenuation record.material.specular))\n         (\"else if\" (== record.material.type\n                        :dielectric)\n                    (=float eta (if (< cos-theta-i 0)\n                                  (/ record.material.ior)\n                                  record.material.ior))\n                    (=vec3 refracted (refract ray.dir facing-normal eta))\n\n                    (\"if\" (all (equal refracted (vec3 0)))\n                          (= outgoing-dir (reflect ray.dir facing-normal)))\n                    (\"else\"\n                     ;fresnel with schlick approximation\n                     (=float temp (/ (- record.material.ior 1)\n                                     (+ 1 record.material.ior)))\n                     (=float pre-fres (* temp temp))\n                     (=float cos-theta (if (< cos-theta-i 0)\n                                         (- cos-theta-i)\n                                         (dot refracted record.normal)))\n                     (=float fresnel (+ pre-fres (* (- 1 pre-fres)\n                                                    (pow (- 1 cos-theta)\n                                                         5))))\n\n                     (\"if\" (< (.x (rand-pcg (+ rand-offset\n                                               gl_FragCoord.xyz\n                                               (* ray.pos\n                                                  ~c/rand-scale))))\n                              fresnel)\n                           (= outgoing-dir (reflect ray.dir facing-normal)))\n                     (\"else\"\n                      (*= attenuation record.material.albedo)\n                      (= outgoing-dir refracted))))\n         (\"else if\" (== record.material.type :lommel)\n                    (*= attenuation record.material.albedo)\n                    (= outgoing-dir (-> facing-normal\n                                        hemisphere-uniform\n                                        .xyz)))\n         (\"else if\" (== record.material.type\n                        :ggx)\n                    (=vec4 dir-sample (vec4 1))\n                    (\"if\" (&& (> (length record.material.albedo)\n                                 0.04)\n                              (< (.x (rand-pcg (+ rand-offset\n                                                  gl_FragCoord.xyz\n                                                  (* ray.pos\n                                                     ~c/rand-scale))))\n                                 0.5))\n                          (= dir-sample (hemisphere-cosine facing-normal))\n                          (= outgoing-dir dir-sample.xyz)\n                          (*= attenuation dir-sample.w)\n                          (*= attenuation (* record.material.albedo\n                                             (dot facing-normal\n                                                  outgoing-dir))))\n                    (\"else\"\n                     (= dir-sample (hemisphere-ggx facing-normal\n                                                   (- ray.dir)\n                                                   record.material.roughness))\n                     (= outgoing-dir dir-sample.xyz)\n                     (*= attenuation dir-sample.w)\n                     (*= attenuation (* (dot facing-normal\n                                             outgoing-dir)\n                                        (ggx facing-normal\n                                             (- ray.dir)\n                                             outgoing-dir\n                                             record.material.roughness\n                                             record.material.specular)))))\n         (Ray (+ record.point\n                 (fudge outgoing-dir))\n              outgoing-dir\n              (+ ray.color\n                 collected-color)\n              attenuation))}\n       exit-color\n       {([Ray] vec3)\n        ([ray]\n         (+ ~(if c/skybox?\n               '(-> skybox\n                    (textureBilinear (bi->uni ray.dir.xy))\n                    .rgb\n                    vec3\n                    (/ ~u32-max))\n               '0)\n            (* (smoothstep -2\n                           1\n                           (dot ray.dir\n                                (vec3 0)))\n               ~(if c/gold-light?\n                  '(* ~c/ambient-light-factor\n                      ~c/sky-gold)\n                  '(vec3 ~c/ambient-light-factor)))\n            ~c/sun-expression))}}\n      :main ((=vec2 pos (+ (getPos)\n                           (* 0.05\n                              (/ size))))\n             (=ivec2 frag-pos (ivec2 gl_FragCoord.xy))\n\n             (=uvec4 meta-color\n                     (texelFetch ray-meta-tex frag-pos \"0\"))\n             (=int step (int meta-color.x))\n             (=int accumulation-index (int meta-color.y))\n\n             (=bool ray-finished false)\n\n             (=vec3 old-accumulated (-> accumulation-tex\n                                        (texelFetch frag-pos \"0\")\n                                        .xyz\n                                        vec3\n                                        (/ ~u32-max)))\n\n             (=vec2 lense (random-point-in-star 5))\n             (*= lense (* ~c/depth-of-field-strength\n                          ~c/depth-of-field-distance))\n             (=vec2 bi-pos (-> pos\n                               uni->bi\n                               (- (/ lense\n                                     ~c/depth-of-field-distance))))\n\n             (=vec3 current-direction (if (== step \"0\")\n                                        (normalize (* (inverse camera)\n                                                      (vec3 bi-pos\n                                                            ~c/field-of-view)))\n                                        #_(-> pos\n                                              (* 2)\n                                              (- 1)\n                                              (vec3 1)\n                                              normalize)\n                                        (-> ray-dir-tex\n                                            (texelFetch frag-pos \"0\")\n                                            .xyz\n                                            vec3\n                                            (/ ~u32-max)\n                                            uni->bi)))\n\n             (=Ray ray\n                   (Ray (if (== step \"0\")\n                          ~(cons 'vec3 c/cam-pos)\n                          (-> ray-pos-tex\n                              (texelFetch frag-pos \"0\")\n                              .xyz\n                              vec3\n                              (/ ~u32-max)\n                              uni->bi))\n                        current-direction\n                        (if (== step \"0\")\n                          (vec3 0)\n                          (-> color-tex\n                              (texelFetch frag-pos \"0\")\n                              .xyz\n                              vec3\n                              (/ ~u32-max)))\n                        (if (== step \"0\")\n                          (vec3 1)\n                          (-> attenuation-tex\n                              (texelFetch frag-pos \"0\")\n                              .xyz\n                              vec3\n                              (/ ~u32-max)))))\n             (~(str \"for(int s=0;s<\" c/bounce-loop-limit \";s++)\")\n              (=Record record (hit-world ray))\n\n              (\"if\" record.hit\n\n                    (= ray (reflect-ray ray record))\n                    (+= step \"1\")\n                    (\"if\" (> step ~(str c/max-steps))\n                          (= ray-finished true)\n                          (= ray.color (vec3 0))\n                          \"break\"))\n\n              (\"else\"\n               (+= ray.color\n                   (* ray.attenuation (exit-color ray)))\n               (= ray-finished true)\n               \"break\"))\n\n             (= Color (uvec4 (uvec3 (* ray.color\n                                       ~u32-max))\n                             ~u32-max-u))\n             (= Position (uvec4 (uvec3 (* (-> ray.pos\n                                              bi->uni)\n                                          ~u32-max))\n                                ~u32-max-u))\n             (= Direction (uvec4 (uvec3 (* (-> ray.dir\n                                               bi->uni)\n                                           ~u32-max))\n                                 ~u32-max-u))\n             (= Accumulated (uvec4\n                             (uvec3\n                              (* (if ray-finished\n                                   (clamp\n                                    (mix old-accumulated\n                                         (/ ray.color\n                                            ~c/max-brightness)\n                                         (/ 1 (+ 1\n                                                 (float accumulation-index))))\n                                    0 1)\n                                   old-accumulated)\n                                 ~u32-max))\n                             ~u32-max-u))\n             (= Attenuation (uvec4 (* ray.attenuation\n                                      ~u32-max)\n                                   ~u32-max-u))\n             (= Meta (uvec4 (if ray-finished\n                              \"0\"\n                              step)\n                            (if ray-finished\n                              (+ accumulation-index \"1\")\n                              accumulation-index)\n                            0\n                            0)))})))\n\n(def worley-frag\n  (u/unquotable\n   (header\n    worley-chunk\n    fbm-chunk\n    pcg-hash-chunk\n    simplex-3d-chunk\n    '{:outputs {fragColor uvec4}\n      :uniforms {size vec2\n                 frame float}\n      :main ((=vec2 pos (/ gl_FragCoord.xy size))\n             (=float worley-fbm (fbm worley-noise\n                                     3\n                                     (vec3 (+ (* pos\n                                                 ~c/cloud-freq)\n                                              (* 0.025\n                                                 (snoise3D (vec3 (* pos 20)\n                                                                 ~(rand 1000)))))\n                                           ~(rand 1000))\n                                     \"5\"\n                                     0.75))\n             (= fragColor (uvec4 (* (mix (vec3 0.129 0.3078 0.9213)\n                                         (vec3 1)\n                                         (-> (- 1 worley-fbm)\n                                             (- 0.3)\n                                             (/ 0.7)\n                                             (max 0)))\n                                    ~u32-max)\n                                 (uvec3 \"0u\"))))})))"]}