shadow$provide.module$node_modules$$serialport$stream$dist$index=function(global,require,module,exports){function allocNewReadPool(poolSize){poolSize=Buffer.allocUnsafe(poolSize);poolSize.used=0;return poolSize}var process=require("module$node_modules$process$browser"),Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";global=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod}};Object.defineProperty(exports,"__esModule",{value:!0});exports.SerialPortStream=
exports.DisconnectedError=void 0;module=require("module$node_modules$stream_browserify$index");const debug=(0,global(require("module$node_modules$debug$src$browser")).default)("serialport/stream");class DisconnectedError extends Error{constructor(message){super(message);this.disconnected=!0}}exports.DisconnectedError=DisconnectedError;const defaultSetFlags={brk:!1,cts:!1,dtr:!0,rts:!0};class SerialPortStream extends module.Duplex{constructor(options,openCallback){options={autoOpen:!0,endOnClose:!1,
highWaterMark:65536,...options};super({highWaterMark:options.highWaterMark});if(!options.binding)throw new TypeError('"Bindings" is invalid pass it as `options.binding`');if(!options.path)throw new TypeError(`"path" is not defined: ${options.path}`);if("number"!==typeof options.baudRate)throw new TypeError(`"baudRate" must be a number: ${options.baudRate}`);this.settings=options;this.closing=this.opening=!1;this._pool=allocNewReadPool(this.settings.highWaterMark);this._kMinPoolSpace=128;this.settings.autoOpen&&
this.open(openCallback)}get path(){return this.settings.path}get baudRate(){return this.settings.baudRate}get isOpen(){var _a,_b;return(null!==(_b=null===(_a=this.port)||void 0===_a?void 0:_a.isOpen)&&void 0!==_b?_b:!1)&&!this.closing}_error(error,callback){callback?callback.call(this,error):this.emit("error",error)}_asyncError(error,callback){process.nextTick(()=>this._error(error,callback))}open(openCallback){if(this.isOpen)return this._asyncError(Error("Port is already open"),openCallback);if(this.opening)return this._asyncError(Error("Port is opening"),
openCallback);const {highWaterMark,binding,autoOpen,endOnClose,...openOptions}=this.settings;this.opening=!0;debug("opening",`path: ${this.path}`);this.settings.binding.open(openOptions).then(port=>{debug("opened",`path: ${this.path}`);this.port=port;this.opening=!1;this.emit("open");openCallback&&openCallback.call(this,null)},err=>{this.opening=!1;debug("Binding #open had an error",err);this._error(err,openCallback)})}update(options,callback){if(!this.isOpen||!this.port)return debug("update attempted, but port is not open"),
this._asyncError(Error("Port is not open"),callback);debug("update",`baudRate: ${options.baudRate}`);this.port.update(options).then(()=>{debug("binding.update","finished");this.settings.baudRate=options.baudRate;callback&&callback.call(this,null)},err=>{debug("binding.update","error",err);return this._error(err,callback)})}write(data,encoding,callback){Array.isArray(data)&&(data=Buffer.from(data));return"function"===typeof encoding?super.write(data,encoding):super.write(data,encoding,callback)}_write(data,
encoding,callback){if(this.isOpen&&this.port)debug("_write",`${data.length} bytes of data`),this.port.write(data).then(()=>{debug("binding.write","write finished");callback(null)},err=>{debug("binding.write","error",err);err.canceled||this._disconnected(err);callback(err)});else this.once("open",()=>{this._write(data,encoding,callback)})}_writev(data,callback){debug("_writev",`${data.length} chunks of data`);data=data.map(write=>write.chunk);this._write(Buffer.concat(data),void 0,callback)}_read(bytesToRead){if(this.isOpen&&
this.port){if(!this._pool||this._pool.length-this._pool.used<this._kMinPoolSpace)debug("_read","discarding the read buffer pool because it is below kMinPoolSpace"),this._pool=allocNewReadPool(this.settings.highWaterMark);var pool=this._pool,toRead=Math.min(pool.length-pool.used,bytesToRead),start=pool.used;debug("_read","reading",{start,toRead});this.port.read(pool,start,toRead).then(({bytesRead})=>{debug("binding.read","finished",{bytesRead});0===bytesRead?(debug("binding.read","Zero bytes read closing readable stream"),
this.push(null)):(pool.used+=bytesRead,this.push(pool.slice(start,start+bytesRead)))},err=>{debug("binding.read","error",err);err.canceled||this._disconnected(err);this._read(bytesToRead)})}else debug("_read","queueing _read for after open"),this.once("open",()=>{this._read(bytesToRead)})}_disconnected(err){this.isOpen?(debug("disconnected",err),this.close(void 0,new DisconnectedError(err.message))):debug("disconnected aborted because already closed",err)}close(callback,disconnectError=null){if(!this.isOpen||
!this.port)return debug("close attempted, but port is not open"),this._asyncError(Error("Port is not open"),callback);this.closing=!0;debug("#close");this.port.close().then(()=>{this.closing=!1;debug("binding.close","finished");this.emit("close",disconnectError);this.settings.endOnClose&&this.emit("end");callback&&callback.call(this,disconnectError)},err=>{this.closing=!1;debug("binding.close","had an error",err);return this._error(err,callback)})}set(options,callback){if(!this.isOpen||!this.port)return debug("set attempted, but port is not open"),
this._asyncError(Error("Port is not open"),callback);options={...defaultSetFlags,...options};debug("#set",options);this.port.set(options).then(()=>{debug("binding.set","finished");callback&&callback.call(this,null)},err=>{debug("binding.set","had an error",err);return this._error(err,callback)})}get(callback){if(!this.isOpen||!this.port)return debug("get attempted, but port is not open"),this._asyncError(Error("Port is not open"),callback);debug("#get");this.port.get().then(status=>{debug("binding.get",
"finished");callback.call(this,null,status)},err=>{debug("binding.get","had an error",err);return this._error(err,callback)})}flush(callback){if(!this.isOpen||!this.port)return debug("flush attempted, but port is not open"),this._asyncError(Error("Port is not open"),callback);debug("#flush");this.port.flush().then(()=>{debug("binding.flush","finished");callback&&callback.call(this,null)},err=>{debug("binding.flush","had an error",err);return this._error(err,callback)})}drain(callback){debug("drain");
this.isOpen&&this.port?this.port.drain().then(()=>{debug("binding.drain","finished");callback&&callback.call(this,null)},err=>{debug("binding.drain","had an error",err);return this._error(err,callback)}):(debug("drain queuing on port open"),this.once("open",()=>{this.drain(callback)}))}}exports.SerialPortStream=SerialPortStream}
//# sourceMappingURL=module$node_modules$$serialport$stream$dist$index.js.map
