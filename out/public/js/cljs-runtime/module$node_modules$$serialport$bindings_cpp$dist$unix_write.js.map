{
"version":3,
"file":"module$node_modules$$serialport$bindings_cpp$dist$unix_write.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/@serialport/bindings-cpp/dist/unix-write.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$serialport$bindings_cpp$dist$unix_write\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unixWrite = void 0;\nconst fs_1 = require(\"fs\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst util_1 = require(\"util\");\nconst logger = (0, debug_1.default)('serialport/bindings-cpp/unixWrite');\nconst writeAsync = (0, util_1.promisify)(fs_1.write);\nconst writable = (binding) => {\n    return new Promise((resolve, reject) => {\n        binding.poller.once('writable', err => (err ? reject(err) : resolve()));\n    });\n};\nconst unixWrite = async ({ binding, buffer, offset = 0, fsWriteAsync = writeAsync }) => {\n    const bytesToWrite = buffer.length - offset;\n    logger('Starting write', buffer.length, 'bytes offset', offset, 'bytesToWrite', bytesToWrite);\n    if (!binding.isOpen || !binding.fd) {\n        throw new Error('Port is not open');\n    }\n    try {\n        const { bytesWritten } = await fsWriteAsync(binding.fd, buffer, offset, bytesToWrite);\n        logger('write returned: wrote', bytesWritten, 'bytes');\n        if (bytesWritten + offset < buffer.length) {\n            if (!binding.isOpen) {\n                throw new Error('Port is not open');\n            }\n            return (0, exports.unixWrite)({ binding, buffer, offset: bytesWritten + offset, fsWriteAsync });\n        }\n        logger('Finished writing', bytesWritten + offset, 'bytes');\n    }\n    catch (err) {\n        logger('write errored', err);\n        if (err.code === 'EAGAIN' || err.code === 'EWOULDBLOCK' || err.code === 'EINTR') {\n            if (!binding.isOpen) {\n                throw new Error('Port is not open');\n            }\n            logger('waiting for writable because of code:', err.code);\n            await writable(binding);\n            return (0, exports.unixWrite)({ binding, buffer, offset, fsWriteAsync });\n        }\n        const disconnectError = err.code === 'EBADF' || // Bad file number means we got closed\n            err.code === 'ENXIO' || // No such device or address probably usb disconnect\n            err.code === 'UNKNOWN' ||\n            err.errno === -1; // generic error\n        if (disconnectError) {\n            err.disconnect = true;\n            logger('disconnecting', err);\n        }\n        logger('error', err);\n        throw err;\n    }\n};\nexports.unixWrite = unixWrite;\n\n};"],
"names":["shadow$provide","global","require","module","exports","__importDefault","mod","__esModule","Object","defineProperty","value","unixWrite","fs_1","debug_1","util_1","logger","default","writeAsync","promisify","write","writable","binding","Promise","resolve","reject","poller","once","err","buffer","offset","fsWriteAsync","bytesToWrite","length","isOpen","fd","Error","bytesWritten","code","errno","disconnect"]
}
