shadow$provide.module$node_modules$$serialport$bindings_cpp$dist$linux=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";global=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod}};Object.defineProperty(exports,"__esModule",{value:!0});exports.LinuxPortBinding=exports.LinuxBinding=void 0;global=global(require("module$node_modules$debug$src$browser"));const linux_list_1=require("module$node_modules$$serialport$bindings_cpp$dist$linux_list"),
poller_1=require("module$node_modules$$serialport$bindings_cpp$dist$poller"),unix_read_1=require("module$node_modules$$serialport$bindings_cpp$dist$unix_read"),unix_write_1=require("module$node_modules$$serialport$bindings_cpp$dist$unix_write"),load_bindings_1=require("module$node_modules$$serialport$bindings_cpp$dist$load_bindings"),debug=(0,global.default)("serialport/bindings-cpp");exports.LinuxBinding={list(){debug("list");return(0,linux_list_1.linuxList)()},async open(options){if(!options||"object"!==
typeof options||Array.isArray(options))throw new TypeError('"options" is not an object');if(!options.path)throw new TypeError('"path" is not a valid port');if(!options.baudRate)throw new TypeError('"baudRate" is not a valid baudRate');debug("open");options=Object.assign({vmin:1,vtime:0,dataBits:8,lock:!0,stopBits:1,parity:"none",rtscts:!1,xon:!1,xoff:!1,xany:!1,hupcl:!0},options);const fd=await (0,load_bindings_1.asyncOpen)(options.path,options);this.fd=fd;return new LinuxPortBinding(fd,options)}};
class LinuxPortBinding{constructor(fd,openOptions){this.fd=fd;this.openOptions=openOptions;this.poller=new poller_1.Poller(fd);this.writeOperation=null}get isOpen(){return null!==this.fd}async close(){debug("close");if(!this.isOpen)throw Error("Port is not open");const fd=this.fd;this.poller.stop();this.poller.destroy();this.fd=null;await (0,load_bindings_1.asyncClose)(fd)}async read(buffer,offset,length){if(!Buffer.isBuffer(buffer))throw new TypeError('"buffer" is not a Buffer');if("number"!==typeof offset||
isNaN(offset))throw new TypeError(`"offset" is not an integer got "${isNaN(offset)?"NaN":typeof offset}"`);if("number"!==typeof length||isNaN(length))throw new TypeError(`"length" is not an integer got "${isNaN(length)?"NaN":typeof length}"`);debug("read");if(buffer.length<offset+length)throw Error("buffer is too small");if(!this.isOpen)throw Error("Port is not open");return(0,unix_read_1.unixRead)({binding:this,buffer,offset,length})}async write(buffer){if(!Buffer.isBuffer(buffer))throw new TypeError('"buffer" is not a Buffer');
debug("write",buffer.length,"bytes");if(!this.isOpen)throw debug("write","error port is not open"),Error("Port is not open");return this.writeOperation=(async()=>{0!==buffer.length&&(await (0,unix_write_1.unixWrite)({binding:this,buffer}),this.writeOperation=null)})()}async update(options){if(!options||"object"!==typeof options||Array.isArray(options))throw TypeError('"options" is not an object');if("number"!==typeof options.baudRate)throw new TypeError('"options.baudRate" is not a number');debug("update");
if(!this.isOpen)throw Error("Port is not open");await (0,load_bindings_1.asyncUpdate)(this.fd,options)}async set(options){if(!options||"object"!==typeof options||Array.isArray(options))throw new TypeError('"options" is not an object');debug("set");if(!this.isOpen)throw Error("Port is not open");await (0,load_bindings_1.asyncSet)(this.fd,options)}async get(){debug("get");if(!this.isOpen)throw Error("Port is not open");return(0,load_bindings_1.asyncGet)(this.fd)}async getBaudRate(){debug("getBaudRate");
if(!this.isOpen)throw Error("Port is not open");return(0,load_bindings_1.asyncGetBaudRate)(this.fd)}async flush(){debug("flush");if(!this.isOpen)throw Error("Port is not open");await (0,load_bindings_1.asyncFlush)(this.fd)}async drain(){debug("drain");if(!this.isOpen)throw Error("Port is not open");await this.writeOperation;await (0,load_bindings_1.asyncDrain)(this.fd)}}exports.LinuxPortBinding=LinuxPortBinding}
//# sourceMappingURL=module$node_modules$$serialport$bindings_cpp$dist$linux.js.map
