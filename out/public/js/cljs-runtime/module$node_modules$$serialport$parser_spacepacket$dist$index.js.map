{
"version":3,
"file":"module$node_modules$$serialport$parser_spacepacket$dist$index.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/@serialport/parser-spacepacket/dist/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$serialport$parser_spacepacket$dist$index\"] = function(global,require,module,exports) {\nvar Buffer = require('buffer').Buffer;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpacePacketParser = void 0;\nconst stream_1 = require(\"stream\");\nconst utils_1 = require(\"./utils\");\n/**\n * A Transform stream that accepts a stream of octet data and converts it into an object\n * representation of a CCSDS Space Packet. See https://public.ccsds.org/Pubs/133x0b2e1.pdf for a\n * description of the Space Packet format.\n */\nclass SpacePacketParser extends stream_1.Transform {\n    /**\n     * A Transform stream that accepts a stream of octet data and emits object representations of\n     * CCSDS Space Packets once a packet has been completely received.\n     * @param {Object} [options] Configuration options for the stream\n     * @param {Number} options.timeCodeFieldLength The length of the time code field within the data\n     * @param {Number} options.ancillaryDataFieldLength The length of the ancillary data field within the data\n     */\n    constructor(options = {}) {\n        super({ ...options, objectMode: true });\n        // Set the constants for this Space Packet Connection; these will help us parse incoming data\n        // fields:\n        this.timeCodeFieldLength = options.timeCodeFieldLength || 0;\n        this.ancillaryDataFieldLength = options.ancillaryDataFieldLength || 0;\n        this.dataSlice = this.timeCodeFieldLength + this.ancillaryDataFieldLength;\n        // These are stateful based on the current packet being received:\n        this.dataBuffer = Buffer.alloc(0);\n        this.headerBuffer = Buffer.alloc(0);\n        this.dataLength = 0;\n        this.expectingHeader = true;\n    }\n    /**\n     * Bundle the header, secondary header if present, and the data into a JavaScript object to emit.\n     * If more data has been received past the current packet, begin the process of parsing the next\n     * packet(s).\n     */\n    pushCompletedPacket() {\n        if (!this.header) {\n            throw new Error('Missing header');\n        }\n        const timeCode = Buffer.from(this.dataBuffer.slice(0, this.timeCodeFieldLength));\n        const ancillaryData = Buffer.from(this.dataBuffer.slice(this.timeCodeFieldLength, this.timeCodeFieldLength + this.ancillaryDataFieldLength));\n        const data = Buffer.from(this.dataBuffer.slice(this.dataSlice, this.dataLength));\n        const completedPacket = {\n            header: { ...this.header },\n            data: data.toString(),\n        };\n        if (timeCode.length > 0 || ancillaryData.length > 0) {\n            completedPacket.secondaryHeader = {};\n            if (timeCode.length) {\n                completedPacket.secondaryHeader.timeCode = timeCode.toString();\n            }\n            if (ancillaryData.length) {\n                completedPacket.secondaryHeader.ancillaryData = ancillaryData.toString();\n            }\n        }\n        this.push(completedPacket);\n        // If there is an overflow (i.e. we have more data than the packet we just pushed) begin parsing\n        // the next packet.\n        const nextChunk = Buffer.from(this.dataBuffer.slice(this.dataLength));\n        if (nextChunk.length >= utils_1.HEADER_LENGTH) {\n            this.extractHeader(nextChunk);\n        }\n        else {\n            this.headerBuffer = nextChunk;\n            this.dataBuffer = Buffer.alloc(0);\n            this.expectingHeader = true;\n            this.dataLength = 0;\n            this.header = undefined;\n        }\n    }\n    /**\n     * Build the Stream's headerBuffer property from the received Buffer chunk; extract data from it\n     * if it's complete. If there's more to the chunk than just the header, initiate handling the\n     * packet data.\n     * @param chunk -  Build the Stream's headerBuffer property from\n     */\n    extractHeader(chunk) {\n        const headerAsBuffer = Buffer.concat([this.headerBuffer, chunk]);\n        const startOfDataBuffer = headerAsBuffer.slice(utils_1.HEADER_LENGTH);\n        if (headerAsBuffer.length >= utils_1.HEADER_LENGTH) {\n            this.header = (0, utils_1.convertHeaderBufferToObj)(headerAsBuffer);\n            this.dataLength = this.header.dataLength;\n            this.headerBuffer = Buffer.alloc(0);\n            this.expectingHeader = false;\n        }\n        else {\n            this.headerBuffer = headerAsBuffer;\n        }\n        if (startOfDataBuffer.length > 0) {\n            this.dataBuffer = Buffer.from(startOfDataBuffer);\n            if (this.dataBuffer.length >= this.dataLength) {\n                this.pushCompletedPacket();\n            }\n        }\n    }\n    _transform(chunk, encoding, cb) {\n        if (this.expectingHeader) {\n            this.extractHeader(chunk);\n        }\n        else {\n            this.dataBuffer = Buffer.concat([this.dataBuffer, chunk]);\n            if (this.dataBuffer.length >= this.dataLength) {\n                this.pushCompletedPacket();\n            }\n        }\n        cb();\n    }\n    _flush(cb) {\n        const remaining = Buffer.concat([this.headerBuffer, this.dataBuffer]);\n        const remainingArray = Array.from(remaining);\n        this.push(remainingArray);\n        cb();\n    }\n}\nexports.SpacePacketParser = SpacePacketParser;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Buffer","Object","defineProperty","value","SpacePacketParser","stream_1","utils_1","Transform","constructor","options","objectMode","timeCodeFieldLength","ancillaryDataFieldLength","dataSlice","dataBuffer","alloc","headerBuffer","dataLength","expectingHeader","pushCompletedPacket","header","Error","timeCode","from","slice","ancillaryData","data","completedPacket","toString","length","secondaryHeader","push","nextChunk","HEADER_LENGTH","extractHeader","undefined","chunk","headerAsBuffer","concat","startOfDataBuffer","convertHeaderBufferToObj","_transform","encoding","cb","_flush","remaining","remainingArray","Array"]
}
