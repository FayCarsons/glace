{
"version":3,
"file":"module$node_modules$$serialport$bindings_cpp$dist$unix_read.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/@serialport/bindings-cpp/dist/unix-read.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$serialport$bindings_cpp$dist$unix_read\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unixRead = void 0;\nconst util_1 = require(\"util\");\nconst fs_1 = require(\"fs\");\nconst errors_1 = require(\"./errors\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst logger = (0, debug_1.default)('serialport/bindings-cpp/unixRead');\nconst readAsync = (0, util_1.promisify)(fs_1.read);\nconst readable = (binding) => {\n    return new Promise((resolve, reject) => {\n        if (!binding.poller) {\n            throw new Error('No poller on bindings');\n        }\n        binding.poller.once('readable', err => (err ? reject(err) : resolve()));\n    });\n};\nconst unixRead = async ({ binding, buffer, offset, length, fsReadAsync = readAsync, }) => {\n    logger('Starting read');\n    if (!binding.isOpen || !binding.fd) {\n        throw new errors_1.BindingsError('Port is not open', { canceled: true });\n    }\n    try {\n        const { bytesRead } = await fsReadAsync(binding.fd, buffer, offset, length, null);\n        if (bytesRead === 0) {\n            return (0, exports.unixRead)({ binding, buffer, offset, length, fsReadAsync });\n        }\n        logger('Finished read', bytesRead, 'bytes');\n        return { bytesRead, buffer };\n    }\n    catch (err) {\n        logger('read error', err);\n        if (err.code === 'EAGAIN' || err.code === 'EWOULDBLOCK' || err.code === 'EINTR') {\n            if (!binding.isOpen) {\n                throw new errors_1.BindingsError('Port is not open', { canceled: true });\n            }\n            logger('waiting for readable because of code:', err.code);\n            await readable(binding);\n            return (0, exports.unixRead)({ binding, buffer, offset, length, fsReadAsync });\n        }\n        const disconnectError = err.code === 'EBADF' || // Bad file number means we got closed\n            err.code === 'ENXIO' || // No such device or address probably usb disconnect\n            err.code === 'UNKNOWN' ||\n            err.errno === -1; // generic error\n        if (disconnectError) {\n            err.disconnect = true;\n            logger('disconnecting', err);\n        }\n        throw err;\n    }\n};\nexports.unixRead = unixRead;\n\n};"],
"names":["shadow$provide","global","require","module","exports","__importDefault","mod","__esModule","Object","defineProperty","value","unixRead","util_1","fs_1","errors_1","logger","debug_1","default","readAsync","promisify","read","readable","binding","Promise","resolve","reject","poller","Error","once","err","buffer","offset","length","fsReadAsync","isOpen","fd","BindingsError","canceled","bytesRead","code","errno","disconnect"]
}
