{
"version":3,
"file":"module$node_modules$$serialport$parser_readline$dist$index.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,0DAAA,CAA+E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CACvH,IAAIC,OAASH,OAAA,CAAQ,kCAAR,CAAkBG,CAAAA,MAC/B,aACAC,OAAOC,CAAAA,cAAP,CAAsBH,OAAtB,CAA+B,YAA/B,CAA6C,CAAEI,MAAO,CAAA,CAAT,CAA7C,CACAJ,QAAQK,CAAAA,cAAR,CAAyB,IAAK,EACxBC,OAAAA,CAAqBR,OAAA,CAAQ,6DAAR,CAK3B,MAAMO,eAAN,QAA6BC,OAAmBC,CAAAA,eAAhD,CACIC,WAAW,CAACC,OAAD,CAAU,CACXC,OAAAA,CAAO,CACTC,UAAWV,MAAOW,CAAAA,IAAP,CAAY,IAAZ,CAAkB,MAAlB,CADF,CAETC,SAAU,MAFD,CAGT,GAAGJ,OAHM,CAKiB,SAA9B;AAAI,MAAOC,QAAKC,CAAAA,SAAhB,GACID,OAAKC,CAAAA,SADT,CACqBV,MAAOW,CAAAA,IAAP,CAAYF,OAAKC,CAAAA,SAAjB,CAA4BD,OAAKG,CAAAA,QAAjC,CADrB,CAGA,MAAA,CAAMH,OAAN,CATiB,CADzB,CAaAV,OAAQK,CAAAA,cAAR,CAAyBA,cAvB8F;",
"sources":["node_modules/@serialport/parser-readline/dist/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$serialport$parser_readline$dist$index\"] = function(global,require,module,exports) {\nvar Buffer = require('buffer').Buffer;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadlineParser = void 0;\nconst parser_delimiter_1 = require(\"@serialport/parser-delimiter\");\n/**\n *  A transform stream that emits data after a newline delimiter is received.\n * @summary To use the `Readline` parser, provide a delimiter (defaults to `\\n`). Data is emitted as string controllable by the `encoding` option (defaults to `utf8`).\n */\nclass ReadlineParser extends parser_delimiter_1.DelimiterParser {\n    constructor(options) {\n        const opts = {\n            delimiter: Buffer.from('\\n', 'utf8'),\n            encoding: 'utf8',\n            ...options,\n        };\n        if (typeof opts.delimiter === 'string') {\n            opts.delimiter = Buffer.from(opts.delimiter, opts.encoding);\n        }\n        super(opts);\n    }\n}\nexports.ReadlineParser = ReadlineParser;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Buffer","Object","defineProperty","value","ReadlineParser","parser_delimiter_1","DelimiterParser","constructor","options","opts","delimiter","from","encoding"]
}
