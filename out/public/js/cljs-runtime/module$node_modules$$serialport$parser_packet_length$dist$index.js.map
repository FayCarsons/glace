{
"version":3,
"file":"module$node_modules$$serialport$parser_packet_length$dist$index.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,+DAAA,CAAoF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAC5H,IAAIC,OAASH,OAAA,CAAQ,kCAAR,CAAkBG,CAAAA,MAC/B,aACAC,OAAOC,CAAAA,cAAP,CAAsBH,OAAtB,CAA+B,YAA/B,CAA6C,CAAEI,MAAO,CAAA,CAAT,CAA7C,CACAJ,QAAQK,CAAAA,kBAAR,CAA6B,IAAK,EAC5BC,OAAAA,CAAWR,OAAA,CAAQ,6CAAR,CAcjB,MAAMO,mBAAN,QAAiCC,OAASC,CAAAA,SAA1C,CACIC,WAAW,CAACC,OAAA,CAAU,EAAX,CAAe,CACtB,KAAA,CAAMA,OAAN,CACA,OAAM,CAAEC,SAAA,CAAY,GAAd,CAAoBC,cAAA,CAAiB,CAArC,CAAwCC,WAAA,CAAc,CAAtD,CAAyDC,YAAA,CAAe,CAAxE;AAA2EC,MAAA,CAAS,GAApF,CAAA,CAA6FL,OACnG,KAAKM,CAAAA,IAAL,CAAY,CACRL,SADQ,CAERC,cAFQ,CAGRC,WAHQ,CAIRC,YAJQ,CAKRC,MALQ,CAOZ,KAAKE,CAAAA,MAAL,CAAcf,MAAOgB,CAAAA,KAAP,CAAa,CAAb,CACd,KAAKC,CAAAA,KAAL,CAAa,CAAA,CAXS,CAa1BC,UAAU,CAACC,KAAD,CAAQC,QAAR,CAAkBC,EAAlB,CAAsB,CAC5B,IAASC,QAAT,CAAe,CAAf,CAAkBA,QAAlB,CAAwBH,KAAMI,CAAAA,MAA9B,CAAsCD,QAAA,EAAtC,CAA6C,CACzC,IAAME,KAAOL,KAAA,CAAMG,QAAN,CACTE,KAAJ,GAAa,IAAKV,CAAAA,IAAKL,CAAAA,SAAvB,GACI,IAAKQ,CAAAA,KADT,CACiB,CAAA,CADjB,CAGI,EAAA,CAAJ,GAAa,IAAKA,CAAAA,KAAlB,GACI,IAAKF,CAAAA,MACD,CADUf,MAAOyB,CAAAA,MAAP,CAAc,CAAC,IAAKV,CAAAA,MAAN,CAAcf,MAAO0B,CAAAA,IAAP,CAAY,CAACF,IAAD,CAAZ,CAAd,CAAd,CACV,CAAA,IAAKT,CAAAA,MAAOQ,CAAAA,MAAZ,EAAsB,IAAKT,CAAAA,IAAKF,CAAAA,YAAhC,CAA+C,IAAKE,CAAAA,IAAKH,CAAAA,WAAzD,GACMgB,IACF,CADQ,IAAKZ,CAAAA,MAAOa,CAAAA,UAAZ,CAAuB,IAAKd,CAAAA,IAAKF,CAAAA,YAAjC,CAA+C,IAAKE,CAAAA,IAAKH,CAAAA,WAAzD,CACR,CAAA,IAAKI,CAAAA,MAAOQ,CAAAA,MAAZ;AAAsBI,IAAtB,CAA4B,IAAKb,CAAAA,IAAKJ,CAAAA,cAAtC,EAAwDiB,IAAxD,CAA8D,IAAKb,CAAAA,IAAKD,CAAAA,MAF5E,CAFR,IAKY,IAAKgB,CAAAA,IAAL,CAAU,IAAKd,CAAAA,MAAf,CAEA,CADA,IAAKA,CAAAA,MACL,CADcf,MAAOgB,CAAAA,KAAP,CAAa,CAAb,CACd,CAAA,IAAKC,CAAAA,KAAL,CAAa,CAAA,CAPzB,CALyC,CAiB7CI,EAAA,EAlB4B,CAoBhCS,MAAM,CAACT,EAAD,CAAK,CACP,IAAKQ,CAAAA,IAAL,CAAU,IAAKd,CAAAA,MAAf,CACA,KAAKA,CAAAA,MAAL,CAAcf,MAAOgB,CAAAA,KAAP,CAAa,CAAb,CACdK,GAAA,EAHO,CAlCf,CAwCAtB,OAAQK,CAAAA,kBAAR,CAA6BA,kBA3D+F;",
"sources":["node_modules/@serialport/parser-packet-length/dist/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$serialport$parser_packet_length$dist$index\"] = function(global,require,module,exports) {\nvar Buffer = require('buffer').Buffer;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PacketLengthParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that decodes packets with a delimiter and length of payload\n * specified within the data stream.\n * @extends Transform\n * @summary Decodes packets of the general form:\n *       [delimiter][len][payload0] ... [payload0 + len]\n *\n * The length field can be up to 4 bytes and can be at any offset within the packet\n *       [delimiter][header0][header1][len0][len1[payload0] ... [payload0 + len]\n *\n * The offset and number of bytes of the length field need to be provided in options\n * if not 1 byte immediately following the delimiter.\n */\nclass PacketLengthParser extends stream_1.Transform {\n    constructor(options = {}) {\n        super(options);\n        const { delimiter = 0xaa, packetOverhead = 2, lengthBytes = 1, lengthOffset = 1, maxLen = 0xff } = options;\n        this.opts = {\n            delimiter,\n            packetOverhead,\n            lengthBytes,\n            lengthOffset,\n            maxLen,\n        };\n        this.buffer = Buffer.alloc(0);\n        this.start = false;\n    }\n    _transform(chunk, encoding, cb) {\n        for (let ndx = 0; ndx < chunk.length; ndx++) {\n            const byte = chunk[ndx];\n            if (byte === this.opts.delimiter) {\n                this.start = true;\n            }\n            if (true === this.start) {\n                this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);\n                if (this.buffer.length >= this.opts.lengthOffset + this.opts.lengthBytes) {\n                    const len = this.buffer.readUIntLE(this.opts.lengthOffset, this.opts.lengthBytes);\n                    if (this.buffer.length == len + this.opts.packetOverhead || len > this.opts.maxLen) {\n                        this.push(this.buffer);\n                        this.buffer = Buffer.alloc(0);\n                        this.start = false;\n                    }\n                }\n            }\n        }\n        cb();\n    }\n    _flush(cb) {\n        this.push(this.buffer);\n        this.buffer = Buffer.alloc(0);\n        cb();\n    }\n}\nexports.PacketLengthParser = PacketLengthParser;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Buffer","Object","defineProperty","value","PacketLengthParser","stream_1","Transform","constructor","options","delimiter","packetOverhead","lengthBytes","lengthOffset","maxLen","opts","buffer","alloc","start","_transform","chunk","encoding","cb","ndx","length","byte","concat","from","len","readUIntLE","push","_flush"]
}
