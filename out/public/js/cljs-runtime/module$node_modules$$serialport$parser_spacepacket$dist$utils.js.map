{
"version":3,
"file":"module$node_modules$$serialport$parser_spacepacket$dist$utils.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,6DAAA,CAAkF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAE1HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CACAH,QAAQI,CAAAA,wBAAR,CAAmCJ,OAAQK,CAAAA,aAA3C,CAA2D,IAAK,EAChEL,QAAQK,CAAAA,aAAR,CAAwB,CAwCxBL,QAAQI,CAAAA,wBAAR,CAxBkCE,GAADF,EAAS,CACtC,IAAMG,UAAYC,KAAMC,CAAAA,IAAN,CAAWH,GAAII,CAAAA,KAAJ,CAAU,CAAV,CAAaV,OAAQK,CAAAA,aAArB,CAAX,CAAgDM,CAAAA,MAAhD,CAAuD,CAACC,KAAD,CAAQC,IAAR,CAAA,EAAkB,CAX3F,IADIC,IACJ,CADUC,MAAA,CAYsGF,IAZtG,CAAYG,CAAAA,QAAZ,CAAqB,CAArB,CACV,CAAoB,CAApB,CAAOF,IAAIG,CAAAA,MAAX,CAAA,CACIH,IAAA,CAAO,IAAGA,IAAH,EAUgF,OAAA,GAAEF,KAAF,GARpFE,IAQoF,EAAA,CAAzE,CAAuG,EAAvG,CAEZI,IAAAA,CADuC,KACvB,GADHX,SAAUG,CAAAA,KAAV,CAAgB,CAAhB;AAAmB,CAAnB,CACG,CAAa,CAAb,CAAiB,iBACvC,OAAMS,KAAOJ,MAAA,CAAOR,SAAA,CAAU,CAAV,CAAP,CAAb,CACMa,gBAAkBL,MAAA,CAAOR,SAAA,CAAU,CAAV,CAAP,CADxB,CAEMc,KAAOC,QAAA,CAASf,SAAUG,CAAAA,KAAV,CAAgB,CAAhB,CAAmB,EAAnB,CAAT,CAAiC,CAAjC,CAFb,CAGMa,cAAgBD,QAAA,CAASf,SAAUG,CAAAA,KAAV,CAAgB,EAAhB,CAAoB,EAApB,CAAT,CAAkC,CAAlC,CAHtB,CAIMc,WAAaF,QAAA,CAASf,SAAUG,CAAAA,KAAV,CAAgB,EAAhB,CAAoB,EAApB,CAAT,CAAkC,CAAlC,CACbe,UAAAA,CAAaH,QAAA,CAASf,SAAUG,CAAAA,KAAV,CAAgB,CAAC,EAAjB,CAAT,CAA+B,CAA/B,CAAbe,CAAiD,CACvD,OAAO,CACHP,cAAAA,GADG,CAEHQ,eAAgB,CACZL,IADY,CAEZD,eAFY,CAGZD,IAHY,CAFb,CAOHQ,gBAAiB,CACbH,UADa,CAEbD,aAFa,CAPd,CAWHE,WAAAA,SAXG,CAV+B,CApBgF;",
"sources":["node_modules/@serialport/parser-spacepacket/dist/utils.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$serialport$parser_spacepacket$dist$utils\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertHeaderBufferToObj = exports.HEADER_LENGTH = void 0;\nexports.HEADER_LENGTH = 6;\n/**\n * For numbers less than 255, will ensure that their string representation is at least 8 characters long.\n */\nconst toOctetStr = (num) => {\n    let str = Number(num).toString(2);\n    while (str.length < 8) {\n        str = `0${str}`;\n    }\n    return str;\n};\n/**\n * Converts a Buffer of any length to an Object representation of a Space Packet header, provided\n * the received data is in the correct format.\n * @param buf - The buffer containing the Space Packet Header Data\n */\nconst convertHeaderBufferToObj = (buf) => {\n    const headerStr = Array.from(buf.slice(0, exports.HEADER_LENGTH)).reduce((accum, curr) => `${accum}${toOctetStr(curr)}`, '');\n    const isVersion1 = headerStr.slice(0, 3) === '000';\n    const versionNumber = isVersion1 ? 1 : 'UNKNOWN_VERSION';\n    const type = Number(headerStr[3]);\n    const secondaryHeader = Number(headerStr[4]);\n    const apid = parseInt(headerStr.slice(5, 16), 2);\n    const sequenceFlags = parseInt(headerStr.slice(16, 18), 2);\n    const packetName = parseInt(headerStr.slice(18, 32), 2);\n    const dataLength = parseInt(headerStr.slice(-16), 2) + 1;\n    return {\n        versionNumber,\n        identification: {\n            apid,\n            secondaryHeader,\n            type,\n        },\n        sequenceControl: {\n            packetName,\n            sequenceFlags,\n        },\n        dataLength,\n    };\n};\nexports.convertHeaderBufferToObj = convertHeaderBufferToObj;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","convertHeaderBufferToObj","HEADER_LENGTH","buf","headerStr","Array","from","slice","reduce","accum","curr","str","Number","toString","length","versionNumber","type","secondaryHeader","apid","parseInt","sequenceFlags","packetName","dataLength","identification","sequenceControl"]
}
