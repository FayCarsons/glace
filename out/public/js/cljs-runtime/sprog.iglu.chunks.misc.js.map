{"version":3,"sources":["sprog/iglu/chunks/misc.cljc"],"mappings":";AAKA,6CAAA,AAAA,7CAAKA;AAML,8CAAA,9CAAMC,oGAAsBC;AAA5B,AACE,OAACC,8BACA,iBAAMC,mBAAW,0DAAA,1DAACC,6CAAEH;AAApB,AAAA,kDAAA,oOAAA,9JACiB,oBAAA,AAAA,mEAAA,AAAA,rFAAIE,8NACN,oBAAA,AAAA,0DAAA,AAAA,5EAAIA;KAHpB,AAAA;;AAcF,uCAAA,AAAA,vCAAKE;AAUL,mCAAA,AAAA,nCAAKC;AAQL,uCAAA,AAAA,vCAAKC;AAIL,sCAAA,AAAA,tCAAKC;AASL,2CAAA,AAAA,3CAAKC;AAiBL,iDAAA,AAAA,jDAAKC;AAiBL,iDAAA,AAAA,jDAAKC;AAOL,AAAKC,wCACH,AAAA,2CAAA,wDAAA,2CAAA,AAAA,wEAAA,WAEgBK,WAAWC,cAAcC,gBAAgBC;AAFzD,AAAA,uBAAA,+CAAA,AAAA,lEAGmBC,mBAAkBC;qBAHrC,iBAAAT,lCAImBU,6CAAqBN;AAJxC,AAAA,QAAAJ;KAAA;AAAA,AAAA;;;KAAA;AAAA,AAAA;;;KAAA;AAAA,AAAA;;;KAAA;AAAA,AAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,mEAAAD;;;;AAAA,AAAA,kDAAA,wDAAA,2CAAA,8DAAA,iEAAA,AAAAE,6BAAA,2CAAA,4EAAA,yEAAA,4DAAA,EAAA,wDAAA,MAAA,AAAAA,6BAAA,2CAAA,2EAAA,2EAAA,2EAAA,sFAAA,AAAA,mkBAAA,8BAAA,4CAAA,t3CAWkBM,sJACKE,yEAAiBA,6EAEVnB,6CAAEa,sJACCC,yEAAoBC,6EACpBD,4EAAoBC,2lBACzBK,eACAD,eACCE,uDAASC;AAnBtC,AAAA,OAAAX,6BAAA,2CAAA,0EAAA,4DAAA,8BAAA,wDAAA,sDAAA,mDAAA,KAAA,KAAAC,eAAA,qBAAA,KAAA,IAAA,yDAAA,+CAAA,aAAA,4EAAA,6DAAA,8BAAA,wDAAA,sDAAA,mDAAA,KAAA,KAAAA,eAAA,qBAAA,KAAA,IAAA,yDAAA,+CAAA,qBAAA,AAAA,j7BAoByCE,0EAEIM,eAAKD,eACCI,6CAAKV,WACCW,sDACCC,+CAAOH,kCACFP,kFACLU,0HACjBX,2EAEIM,eAAKD,eACCI,6CAAKV,WACCW,sDACCC,+CAAOH,kCACFP,kFACLU;GAnC1D,6DAAA,qFAAA,AAAA,isBAAA,gEAAA,KAAAb,eAAA,sBAAA,KAAAA,eAAA,SAAA,KAAA,IAAA,OAAA,IAAA,9+BAoCkCc,8CAAMb,4EACZE,kzBACME,0CACAD","names":["sprog.iglu.chunks.misc/trivial-vert-source","sprog.iglu.chunks.misc/identity-frag-source","texture-type","clojure.walk/postwalk-replace","float-tex?","cljs.core._EQ_","sprog.iglu.chunks.misc/rescale-chunk","sprog.iglu.chunks.misc/pos-chunk","sprog.iglu.chunks.misc/sigmoid-chunk","sprog.iglu.chunks.misc/sympow-chunk","sprog.iglu.chunks.misc/smoothstair-chunk","sprog.iglu.chunks.misc/bilinear-usampler-chunk","sprog.iglu.chunks.misc/paretto-transform-chunk","sprog.iglu.chunks.misc/gradient-chunk","G__43386","js/Error","clojure.walk/prewalk-replace","cljs.core/List","dimensions","function-name","sample-distance","pos","gradient-fn-name","cljs.core.gensym","dimension-type","cljs.core/cons","cljs.core.map","dim","cljs.core.take","cljs.core.concat","cljs.core.repeat","cljs.core.range"],"sourcesContent":["(ns sprog.iglu.chunks.misc\n  (:require [sprog.util :as u]\n            [clojure.walk :refer [postwalk\n                                  postwalk-replace]]))\n\n(def trivial-vert-source\n  '{:version \"300 es\"\n    :precision {float lowp}\n    :inputs {vertPos vec4}\n    :main ((= gl_Position vertPos))})\n\n(defn identity-frag-source [texture-type]\n  (postwalk-replace\n   (let [float-tex? (= texture-type :f8)]\n     {:sampler-type (if float-tex? 'sampler2D 'usampler2D)\n      :pixel-type (if float-tex? 'vec4 'uvec4)})\n   '{:version \"300 es\"\n     :precision {float highp\n                 sampler2D highp\n                 int highp\n                 usampler2D highp}\n     :uniforms {tex :sampler-type\n                size vec2}\n     :outputs {fragColor :pixel-type}\n     :main ((= fragColor (texture tex (/ gl_FragCoord.xy size))))}))\n\n(def rescale-chunk\n  '{:functions\n    {rescale\n     {([float float float float float] float)\n      ([oldMin oldMax newMin newMax x]\n       (+ newMin\n          (* (- newMax newMin)\n             (/ (- x oldMin)\n                (- oldMax oldMin)))))}}})\n\n(def pos-chunk\n  '{:functions {getPos {([] vec2)\n                        ([]\n                         (=float minDim (min size.x size.y))\n                         (/ (- gl_FragCoord.xy\n                               (* 0.5 (- size minDim)))\n                            minDim))}}})\n\n(def sigmoid-chunk\n  '{:functions {sigmoid {([float] float)\n                         ([x] (/ 1 (+ 1 (exp (- 0 x)))))}}})\n\n(def sympow-chunk\n  '{:functions\n    {sympow\n     {([float float] float)\n      ([x power]\n       (* (sign x)\n          (pow (abs x)\n               power)))}}})\n\n(def smoothstair-chunk\n  '{:functions\n    {smoothstair\n     {([float float float] float)\n      ([x steps steepness]\n       (*= x steps)\n       (=float c (- (/ 2 (- 1 steepness)) 1))\n       (=float p (mod x 1))\n       (/ (+ (floor x)\n             (if (< p 0.5)\n               (/ (pow p c)\n                  (pow 0.5 (- c 1)))\n               (- 1\n                  (/ (pow (- 1 p) c)\n                     (pow 0.5 (- c 1))))))\n          steps))}}})\n\n(def bilinear-usampler-chunk\n  '{:functions\n    {textureBilinear\n     {([usampler2D vec2] vec4)\n      ([tex pos]\n       (=vec2 texSize (vec2 (textureSize tex \"0\")))\n       (=vec2 texCoords (- (* pos texSize) 0.5))\n       (=vec2 gridCoords (+ (floor texCoords) 0.5))\n       (=vec2 tweenCoords (fract texCoords))\n       (mix (mix (vec4 (texture tex (/ gridCoords texSize)))\n                 (vec4 (texture tex (/ (+ gridCoords (vec2 1 0)) texSize)))\n                 tweenCoords.x)\n            (mix (vec4 (texture tex (/ (+ gridCoords (vec2 0 1)) texSize)))\n                 (vec4 (texture tex (/ (+ gridCoords (vec2 1 1)) texSize)))\n                 tweenCoords.x)\n            tweenCoords.y))}}})\n\n(def paretto-transform-chunk\n  '{:functions {paretto\n                {([float float float] float)\n                 ([value shape scale]\n                  (/ (pow (* shape scale) shape)\n                     (pow value (+ shape 1))))}}})\n\n(def gradient-chunk\n  (u/unquotable\n   {:macros {'findGradient\n             (fn [dimensions function-name sample-distance pos]\n               (let [gradient-fn-name (gensym 'gradient)\n                     dimension-type (case dimensions\n                                      1 'float\n                                      2 'vec2\n                                      3 'vec3\n                                      4 'vec4)]\n                 {:chunk\n                  {:functions\n                   {gradient-fn-name\n                    '{([~dimension-type] ~dimension-type)\n                      ([x]\n                       (/ ~(if (= dimensions 1)\n                             '(- (~function-name (+ x ~sample-distance))\n                                 (~function-name (- x ~sample-distance)))\n                             (cons\n                              dimension-type\n                              (map (fn [dim]\n                                     '(- (~function-name\n                                          (+ x\n                                             ~(cons dimension-type\n                                                    (take dimensions\n                                                          (concat\n                                                           (repeat dim 0)\n                                                           (list sample-distance)\n                                                           (repeat 0))))))\n                                         (~function-name\n                                          (- x\n                                             ~(cons dimension-type\n                                                    (take dimensions\n                                                          (concat\n                                                           (repeat dim 0)\n                                                           (list sample-distance)\n                                                           (repeat 0))))))))\n                                   (range dimensions))))\n                          (* ~sample-distance 2)))}}}\n                  :expression (list gradient-fn-name\n                                    pos)}))}}))\n"]}