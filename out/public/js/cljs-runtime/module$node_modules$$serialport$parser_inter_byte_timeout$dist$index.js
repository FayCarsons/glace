shadow$provide.module$node_modules$$serialport$parser_inter_byte_timeout$dist$index=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.InterByteTimeoutParser=void 0;global=require("module$node_modules$stream_browserify$index");class InterByteTimeoutParser extends global.Transform{constructor({maxBufferSize=65536,interval,...transformOptions}){super(transformOptions);if(!interval)throw new TypeError('"interval" is required');
if("number"!==typeof interval||Number.isNaN(interval))throw new TypeError('"interval" is not a number');if(1>interval)throw new TypeError('"interval" is not greater than 0');if("number"!==typeof maxBufferSize||Number.isNaN(maxBufferSize))throw new TypeError('"maxBufferSize" is not a number');if(1>maxBufferSize)throw new TypeError('"maxBufferSize" is not greater than 0');this.maxBufferSize=maxBufferSize;this.currentPacket=[];this.interval=interval}_transform(chunk,encoding,cb){this.intervalID&&clearTimeout(this.intervalID);
for(encoding=0;encoding<chunk.length;encoding++)this.currentPacket.push(chunk[encoding]),this.currentPacket.length>=this.maxBufferSize&&this.emitPacket();this.intervalID=setTimeout(this.emitPacket.bind(this),this.interval);cb()}emitPacket(){this.intervalID&&clearTimeout(this.intervalID);0<this.currentPacket.length&&this.push(Buffer.from(this.currentPacket));this.currentPacket=[]}_flush(cb){this.emitPacket();cb()}}exports.InterByteTimeoutParser=InterByteTimeoutParser}
//# sourceMappingURL=module$node_modules$$serialport$parser_inter_byte_timeout$dist$index.js.map
